{"meta":{"title":"天空","subtitle":"","description":"","author":null,"url":"https://abcdoc-cn.github.io","root":"/"},"pages":[],"posts":[{"title":"VUE 常用方法","slug":"VUE/VUE 常用方法","date":"2021-06-10T07:38:20.000Z","updated":"2021-06-10T07:38:20.000Z","comments":true,"path":"VUE/VUE 常用方法/","link":"","permalink":"https://abcdoc-cn.github.io/VUE/VUE%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组转字符串123var arr = [&#x27;1&#x27;,&#x27;2&#x27;];let str = arr.join(&quot;,&quot;);console.log(str)//1,2 字符串转数组123var str = &#x27;1,2&#x27;let arr = str.split(&#x27;,&#x27;)console.log(arr)// [&quot;1&quot;, &quot;2&quot;] 删除数组元素12//表示先获取这个元素的下标，然后从这个下标开始计算，删除长度为1的元素this.arr.splice(this.arr.indexOf(item), 1); 数组排序12// 排序时按照ASCII码进行排序，先看首个字符的ASCII码值，按照码值进行排序arr.sort();","categories":[{"name":"VUE","slug":"VUE","permalink":"https://abcdoc-cn.github.io/categories/VUE/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"VUE","slug":"VUE","permalink":"https://abcdoc-cn.github.io/tags/VUE/"}],"author":"abcdoc"},{"title":"SpringBoot 跳过测试","slug":"SpringBoot/SpringBoot 跳过测试","date":"2021-06-08T21:05:37.000Z","updated":"2021-06-09T09:11:48.000Z","comments":true,"path":"SpringBoot/SpringBoot 跳过测试/","link":"","permalink":"https://abcdoc-cn.github.io/SpringBoot/SpringBoot%20%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95/","excerpt":"","text":"pom 属性 skipTests1234&lt;properties&gt; &lt;!-- surefire plugin方式跳过maven test， 等同$ mvn package -DskipTests --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;/properties&gt; pom 属性 maven.test.skip1234&lt;properties&gt; &lt;!-- maven方式跳过maven test, 等同$ mvn package -Dmaven.test.skip=true --&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt;&lt;/properties&gt; pom 里面增加插件跳过测试的插件1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 命令行添加 -DskipTests 不执行测试用例 编译测试用例类生成相应的 class 文件至 target/test-classes下。 命令行添加 -Dmaven.test.skip=true 不执行测试用例 不编译测试用例类。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://abcdoc-cn.github.io/categories/SpringBoot/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://abcdoc-cn.github.io/tags/SpringBoot/"}],"author":"Abcdoc"},{"title":"C 基本数据类型大小","slug":"C/C基本数据类型大小","date":"2021-06-08T03:26:05.000Z","updated":"2021-06-08T03:26:05.856Z","comments":true,"path":"C/C基本数据类型大小/","link":"","permalink":"https://abcdoc-cn.github.io/C/C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"","categories":[{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"}]},{"title":"Oracle 查询 - 时间函数","slug":"Oracle/Oracle 查询 - 时间函数","date":"2021-06-07T02:55:37.000Z","updated":"2021-06-07T05:34:46.643Z","comments":true,"path":"Oracle/Oracle 查询 - 时间函数/","link":"","permalink":"https://abcdoc-cn.github.io/Oracle/Oracle%20%E6%9F%A5%E8%AF%A2%20-%20%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"时间查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263-- 30分钟后SELECT sysdate+1/24/2 FROM DUAL;-- 下一小时SELECT sysdate+1/24 FROM DUAL;-- 下一天SELECT sysdate+1 FROM DUAL;-- 日期加减SELECT to_char(sysdate-1,&#x27;yyyymmdd&#x27;) FROM DUAL;-- 下一个星期SELECT sysdate+7 FROM DUAL;-- 下个星期一的日期SELECT Next_day(SYSDATE,&#x27;monday&#x27;) FROM DUAL-- 下个星期五中午SELECT NEXT_DAY(TRUNC(SYSDATE),&#x27;星期五&#x27;) + 12/24 FROM DUAL;-- 下一个月SELECT add_months(sysdate,1) FROM DUAL;-- 下一年SELECT add_months(sysdate,12) FROM DUAL;-- 月份加减SELECT to_char(add_months(sysdate,-1),&#x27;yyyymm&#x27;) FROM DUAL;-- 今天是本月的第几周SELECT TO_CHAR(SYSDATE,&#x27;WW&#x27;) - TO_CHAR(TRUNC(SYSDATE,&#x27;MM&#x27;),&#x27;WW&#x27;) + 1 AS &quot;weekOfMon&quot; FROM DUAL;-- 今天是本年的第几周SELECT TO_CHAR(SYSDATE,&#x27;WW&#x27;) FROM DUAL;-- 本月的天数SELECT to_char(last_day(SYSDATE),&#x27;dd&#x27;) days FROM DUAL;-- 今年的天数SELECT add_months(trunc(sysdate,&#x27;year&#x27;), 12) - trunc(sysdate,&#x27;year&#x27;) from DUAL;-- 本月底最后一秒SELECT TRUNC (ADD_MONTHS (SYSDATE, 1), &#x27;MM&#x27;) - 1 / 24 / 60 / 60 from DUAL;-- 本年底最后一秒SELECT TRUNC (SYSDATE, &#x27;YYYY&#x27;) - 1 / 24 / 60 / 60 from DUAL;-- 将当前时间归到节点SELECT sysdate,trunc(sysdate,&#x27;hh&#x27;)+floor(to_char(sysdate,&#x27;mi&#x27;)/15)*15/60/24 from DUAL; -- 毫秒SELECT TO_TIMESTAMP(&#x27;20101101 14:10:10.123000&#x27;, &#x27;YYYYMMDD HH24:MI:SS.FF&#x27;) FROM DUAL;SELECT TO_TIMESTAMP(&#x27;20101101141010123&#x27;, &#x27;YYYYMMDDHH24MISSFF3&#x27;) FROM DUAL;SELECT TO_CHAR(SYSTIMESTAMP, &#x27;yyyymmddhh24missff3&#x27;) FROM DUAL;-- 两时间差几个月SELECT ROUND(ABS(MONTHS_BETWEEN(SYSDATE,OPEN_TIME))) FROM DUAL;-- 查看本月日期SELECT TRUNC(SYSDATE, &#x27;MM&#x27;) + ROWNUM - 1FROM DUALCONNECT BY ROWNUM &lt;= TO_NUMBER(TO_CHAR(LAST_DAY(SYSDATE), &#x27;dd&#x27;));","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/categories/Oracle/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/tags/Oracle/"}]},{"title":"Oracle 查询 - 表空间","slug":"Oracle/Oracle 查询 - 表空间","date":"2021-06-07T02:53:50.000Z","updated":"2021-06-07T05:35:08.613Z","comments":true,"path":"Oracle/Oracle 查询 - 表空间/","link":"","permalink":"https://abcdoc-cn.github.io/Oracle/Oracle%20%E6%9F%A5%E8%AF%A2%20-%20%E8%A1%A8%E7%A9%BA%E9%97%B4/","excerpt":"","text":"表空间表空间利用率1234567891011121314151617181920212223242526272829303132333435SELECT D.TABLESPACE_NAME, SPACE || &#x27;M&#x27; &quot;SUM_SPACE(M)&quot;, BLOCKS &quot;SUM_BLOCKS&quot;, SPACE - NVL(FREE_SPACE, 0) || &#x27;M&#x27; &quot;USED_SPACE(M)&quot;, ROUND((1 - NVL(FREE_SPACE, 0) / SPACE) * 100, 2) || &#x27;%&#x27; &quot;USED_RATE(%)&quot;, FREE_SPACE || &#x27;M&#x27; &quot;FREE_SPACE(M)&quot;FROM (SELECT TABLESPACE_NAME, ROUND(SUM(BYTES) / (1024 * 1024), 2) SPACE, SUM(BLOCKS) BLOCKS FROM DBA_DATA_FILES GROUP BY TABLESPACE_NAME) D, (SELECT TABLESPACE_NAME, ROUND(SUM(BYTES) / (1024 * 1024), 2) FREE_SPACE FROM DBA_FREE_SPACE GROUP BY TABLESPACE_NAME) FWHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME(+)UNION ALL --如果有临时表空间SELECT D.TABLESPACE_NAME, SPACE || &#x27;M&#x27; &quot;SUM_SPACE(M)&quot;, BLOCKS SUM_BLOCKS, USED_SPACE || &#x27;M&#x27; &quot;USED_SPACE(M)&quot;, ROUND(NVL(USED_SPACE, 0) / SPACE * 100, 2) || &#x27;%&#x27; &quot;USED_RATE(%)&quot;, NVL(FREE_SPACE, 0) || &#x27;M&#x27; &quot;FREE_SPACE(M)&quot;FROM (SELECT TABLESPACE_NAME, ROUND(SUM(BYTES) / (1024 * 1024), 2) SPACE, SUM(BLOCKS) BLOCKS FROM DBA_TEMP_FILES GROUP BY TABLESPACE_NAME) D, (SELECT TABLESPACE_NAME, ROUND(SUM(BYTES_USED) / (1024 * 1024), 2) USED_SPACE, ROUND(SUM(BYTES_FREE) / (1024 * 1024), 2) FREE_SPACE FROM V$TEMP_SPACE_HEADER GROUP BY TABLESPACE_NAME) FWHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME(+)ORDER BY 1; 表空间名称及大小1234select t.tablespace_name, round(sum(bytes/(1024*1024)),0) ts_sizefrom dba_tablespaces t, dba_data_files dwhere t.tablespace_name = d.tablespace_namegroup by t.tablespace_name; 表空间物理文件的名称、位置及大小123select tablespace_name, file_id, file_name, round(bytes/(1024*1024),0) total_spacefrom dba_data_filesorder by tablespace_name; 查看表空间是否自动增长1SELECT FILE_NAME,TABLESPACE_NAME,AUTOEXTENSIBLE FROM dba_data_files; 修改数据库文件大小（10G）1alter database datafile &#x27;/ora/oradata/radius/undo.dbf&#x27; resize 10240M; 设置表空间自动增长123456# 打开自动增长ALTER DATABASE DATAFILE &#x27;c:\\SmartDB01.ora&#x27; AUTOEXTEND ON;# 每次自动增长200mALTER DATABASE DATAFILE &#x27;c:\\SmartDB01.ora&#x27; AUTOEXTEND ON NEXT 200M;# 每次自动增长200m，数据表最大不超过1GALTER DATABASE DATAFILE &#x27;c:\\SmartDB01.ora&#x27; AUTOEXTEND ON NEXT 200M MAXSIZE 1024M;","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/categories/Oracle/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/tags/Oracle/"}]},{"title":"MySQL 亿级表格插入一列","slug":"MySQL/MySQL 亿级表格插入一列","date":"2021-06-07T02:29:48.000Z","updated":"2021-06-07T02:29:48.923Z","comments":true,"path":"MySQL/MySQL 亿级表格插入一列/","link":"","permalink":"https://abcdoc-cn.github.io/MySQL/MySQL%20%E4%BA%BF%E7%BA%A7%E8%A1%A8%E6%A0%BC%E6%8F%92%E5%85%A5%E4%B8%80%E5%88%97/","excerpt":"","text":"背景mysql中，一张表里有3亿数据，未分表，要求是在这个大表里添加一列数据。数据库不能停，并且还有增删改操作。 实现方法MySQL 5.6（包含） 以后的版本引入了在线 DDL 的功能 1Alter table 你的表 , ALGORITHM [=] &#123;DEFAULT|INSTANT|INPLACE|COPY&#125;, LOCK [=] &#123; DEFAULT| NONE| SHARED| EXCLUSIVE &#125; 其中的参数： ALGORITHM：DEFAULT：默认方式，在 MySQL 8.0中，如果未显示指定 ALGORITHM，那么会优先选择 INSTANT 算法，如果不行再使用 INPLACE 算法，如果不支持 INPLACE 算法则使用 COPY 的方式完成INSTANT：8.0 中新添加的算法，添加列是立即返回。但是不能是虚拟列。这个原理很简单，对于新建一列，表所有原有数据并不是立刻发生变化，只是在表字典里面记录下这个列和默认值，对于默认的 Dynamic 行格式（其实就是 Compressed 的变种），如果更新了这一列则原有数据标记为删除在末尾追加更新后的记录。这样做就是没有提前预留出列空间，之后更新可能经常会发生行记录空间变动。但是对于大多数业务，都是最近的时间的记录才会修改，所以问题不大。INPLACE：在原表上直接进行修改，不会拷贝临时表，可以逐条记录修改，不会产生大量的 undolog 以及 redolog，不会占用很多 buffer。可以避免重建表带来的IO和CPU消耗，保证期间依然良好的性能和并发。COPY：拷贝到临时新表上进行修改。由于记录拷贝，会产生大量的 undolog 以及 redolog，并占用很多 buffer，对业务性能有影响。LOCK：DEFAULT：和 ALGORITHM 的 DEFAULT 类似NONE：无锁，允许并发读取和更新表SHARED：共享锁，允许读取不允许更新EXCLUSIVE：不允许读取和更新 在线 DDL 的过程","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/tags/MySQL/"},{"name":"高可用","slug":"高可用","permalink":"https://abcdoc-cn.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"}]},{"title":"二分查找算法","slug":"算法/二分查找算法","date":"2021-06-07T01:59:37.000Z","updated":"2021-06-10T07:50:46.000Z","comments":true,"path":"算法/二分查找算法/","link":"","permalink":"https://abcdoc-cn.github.io/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","excerpt":"","text":"二分查找算法一种在有序数组中查找某一特定元素的搜索算法 时间复杂度： O(logn) 从数组的中间元素开始，如果中间元素正好是要查找的元素，搜索结束； 如果某一特定元素大于或小于中间元素，在数组大于或小于中间元素的那一半中查找，跟开始一样从中间查找 如果某一步骤数组为空，代表找不到 12345678910111213141516171819public static int binary(int[] arr, int data) &#123; int min = 0; int max = arr.length - 1; int mid; while (min &lt;= max) &#123; // 第一种方法：防止溢出 mid = min + (max - min) / 2; // 第二种方法：无符号位运算符的优先级较低，先括起来 // mid = min + ((max - min) &gt;&gt;&gt; 1); if (arr[mid] &gt; data) &#123; max = mid - 1; &#125; else if (arr[mid] &lt; data) &#123; min = mid + 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":null},{"title":"SYN泛洪攻击","slug":"计算机网络/SYN泛洪攻击","date":"2021-06-07T01:58:12.000Z","updated":"2021-06-07T01:58:12.323Z","comments":true,"path":"计算机网络/SYN泛洪攻击/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SYN%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/","excerpt":"","text":"SYN泛洪攻击 利用 TCP 三次握手机制的缺陷进行攻击 主要发生在 OSI 第四层 DoS 攻击的一种 原理 客户端（攻击者）发送 TCP SYN，服务器返回 ACK 以后，客户端不再进行确认 此时连接就处在了一个挂起的状态，服务器收不到再确认的一个消息，还会重复发送 ACK 给客户端 解决办法 优化主机系统设置 降低 SYN timeout 时间，使得主机尽快释放半连接的占用 采用 SYN cookie 设置，短时间内收到了某个 IP 的重复 SYN 请求，我们就认为受到了攻击，可以设置防火墙进行拦截","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"HTTPS","slug":"计算机网络/HTTPS","date":"2021-06-07T01:48:21.000Z","updated":"2021-06-07T01:48:21.050Z","comments":true,"path":"计算机网络/HTTPS/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/","excerpt":"","text":"HTTPS 全称：Hypertext Transfer Protocol over Secure Socket Layer HTTP 的安全版，在 HTTP 下加入 SSL 层，默认端口号： 443 不是一种新的协议 先让 HTTP 与 SSL 通信，再由 SSL 和 TCP 通信 加密对称密钥加密非对称密钥加密HTTPS 使用对称 + 非对称加密方式","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"SSL","slug":"计算机网络/SSL","date":"2021-06-07T01:47:21.000Z","updated":"2021-06-07T01:47:21.632Z","comments":true,"path":"计算机网络/SSL/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SSL/","excerpt":"","text":"SSL 全称：安全套接字层 （Secure Socket Layer ） 有三个版本： SSL 1.0 SSL 2.0 SSL 3.0 使用三种验证机制 数据加密（防窃听） 身份验证（防伪装） 消息完成性（防篡改） 支持各种应用层协议 位于 应用层和传输层之间","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Java 锁升级","slug":"Java/Java 锁升级","date":"2021-06-04T09:21:11.000Z","updated":"2021-06-04T09:24:59.711Z","comments":true,"path":"Java/Java 锁升级/","link":"","permalink":"https://abcdoc-cn.github.io/Java/Java%20%E9%94%81%E5%8D%87%E7%BA%A7/","excerpt":"","text":"Java 锁升级偏向锁当只有一个线程使用synchronized给对象加锁时，其实在对象头中只是记录这个线程的id，并没有实际加锁，此时称为偏向锁（即无锁，对象头中锁标志位为01），效率较高； 自旋锁 当有线程争用锁时，锁升级为自旋锁（默认自旋10次，自旋的意义是让线程自旋等待去获取锁而不是阻塞，减少因线程阻塞带来的线程切换（线程挂起、恢复））， 线程自旋将占用CPU时间， 自旋结束后进入等待队列阻塞，所以，自旋锁适合少数线程争用锁的情况，否则会占用CPU资源过高； 自适应自旋锁自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定， 因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间； 轻量级锁 当线程自旋指定次数后仍无法获得锁时，将升级为轻量级锁（对象头中锁标志位为00）， 轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等； 重量级锁当锁竞争激励时，将升级为重量级锁（对象头中锁标志位为10）去操作系统请求资源。","categories":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://abcdoc-cn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java 线程的6种状态","slug":"Java/Java-线程的6种状态","date":"2021-06-04T08:59:26.000Z","updated":"2021-06-07T05:05:28.107Z","comments":true,"path":"Java/Java-线程的6种状态/","link":"","permalink":"https://abcdoc-cn.github.io/Java/Java-%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/","excerpt":"","text":"Java 线程的6种状态 New：线程刚刚创建，还没有启动 RUNNABLE：可运行状态（调用start()方法后进入可运行状态），由线程调度器可以安排执行。包括READY和RUNNING两种细分状态，READY状态的线程主动调用Thread.yiled()方法让出CPU资源，等待线程调度器重新调起线程后获得CPU时间片继续执行，RUNNING状态的线程是正在执行的线程，正在执行的线程的执行时间就是CPU时间片的大小 WAITING：线程等待被唤醒，调用Object的notify()或者notifyAll()方法后可以唤醒线程 TIMED WAITING：线程等待指定时间后自动唤醒 BLOCKED：线程被阻塞，正在等待synchronied锁，获得锁后进入RUNNABLE状态 TERMINATED：线程结束，run()方法执行完成或者异常退出","categories":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://abcdoc-cn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java 创建线程的 5 种方法","slug":"Java/Java 创建线程的 5 种方法","date":"2021-06-04T08:53:20.000Z","updated":"2021-06-04T08:53:20.095Z","comments":true,"path":"Java/Java 创建线程的 5 种方法/","link":"","permalink":"https://abcdoc-cn.github.io/Java/Java%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%205%20%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"Java 创建线程的 5 种方法 继承Thread 实现Runnable接口，这种方式更加灵活，因为实现接口后还可以继承其他类 使用lambda方式 通过线程池创建线程 实现Callable接口，通过指定泛型来决定call()方法返回值的类型，相比实现Runnable接口来说，重写的call()方法可以有返回值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.concurrent.*;/** * *创建线程的五种方法 */public class CreateThread &#123; //方式一：继承Thread static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;Hello MyThread!&quot;); &#125; &#125; // 方式二：实现Runnable接口 static class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;Hello MyRunnable!&quot;); &#125; &#125; // 方式五：实现Callable接口 static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;Hello MyCallable!&quot;); return &quot;success&quot;; &#125; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 方式一的启动线程 new MyThread().start(); // 方式二的启动线程 new Thread(new MyRunnable()).start(); // 方式三：lambda方式 new Thread(() -&gt; &#123; System.out.println(&quot;Hello Lambda!&quot;); &#125;).start(); // 方式四：线程池方式 ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; System.out.println(&quot;Hello ThreadPool&quot;); &#125;); // 方式五的启动线程方式之一 // 也可以使用以下线程池的方式将Callable对象传进去 FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyCallable()); Thread thread = new Thread(task); thread.start(); System.out.println(task.get()); // 方式五的启动线程方式之二 // 以线程池的方式来启动Callable类型的线程 // ExecutorService的submit方法可以接收Runnable或者Callable的对象 // Future代表是异步的，其get()方法是阻塞的，直到submit()方法中的对象（线程）就绪 Future&lt;String&gt; submit = executorService.submit(new MyCallable()); String s = submit.get(); System.out.println(s); executorService.shutdown(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://abcdoc-cn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Electron异常：Failed to fetch extension","slug":"Electron/Electron 异常：Failed to fetch extension","date":"2021-06-04T01:54:24.000Z","updated":"2021-06-07T02:32:13.233Z","comments":true,"path":"Electron/Electron 异常：Failed to fetch extension/","link":"","permalink":"https://abcdoc-cn.github.io/Electron/Electron%20%E5%BC%82%E5%B8%B8%EF%BC%9AFailed%20to%20fetch%20extension/","excerpt":"","text":"问题现象123456Failed to fetch extension, trying 4 more timesFailed to fetch extension, trying 3 more timesFailed to fetch extension, trying 2 more timesFailed to fetch extension, trying 1 more timesFailed to fetch extension, trying 0 more timesVue Devtools failed to install: Error: net::ERR_TIMED_OUT 错误原因background.js 中安装 devtools 导致 解决方法background.js中这几行注释掉 1234567891011app.on(&#x27;ready&#x27;, async () =&gt; &#123; // if (isDevelopment &amp;&amp; !process.env.IS_TEST) &#123; // // Install Vue Devtools // try &#123; // await installExtension(VUEJS_DEVTOOLS) // &#125; catch (e) &#123; // console.error(&#x27;Vue Devtools failed to install:&#x27;, e.toString()) // &#125; // &#125; createWindow()&#125;)","categories":[{"name":"Electron","slug":"Electron","permalink":"https://abcdoc-cn.github.io/categories/Electron/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://abcdoc-cn.github.io/tags/Electron/"},{"name":"异常处理","slug":"异常处理","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"GCC 编译过程","slug":"GCC/GCC 编译过程","date":"2021-04-30T07:43:45.237Z","updated":"2021-04-30T09:34:20.656Z","comments":true,"path":"GCC/GCC 编译过程/","link":"","permalink":"https://abcdoc-cn.github.io/GCC/GCC%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"GCC 编译过程 GCC（GUC 编译器套装，GNU Compiler Collectipon） 预处理(Prepressing)执行命令1gcc -E hello.c -o hello.i 处理过程 将所有的”#define”删除，并且展开所有的宏定义 处理所有条件预编译指令，比如”#if”、”#ifdef”、“#elif”、“#else”、”#endif”。 处理”#include”预编译指令 将被包含的文件插入到该项预编译指令的位置 注意：这个过程是递归进行的，也就是说被包含的文件可能还包含其它文件。 删除所有的注释”//”和”/* */” 添加行号和文件名标识 便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 保留所有的#pragma编译器指令 编译器须要使用它们 编译(Compilation) 编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件 执行命令1gcc -S hello.i -o hello.s 现在版本的GCC把预编译和编译两个步骤合成一个步骤，使用如下命令，也会生成 hello.s 文件 1gcc -S hello.c -o hello.s 对于 C 语言来说，这个预编译和编译的程序是cc1 对于 C++ 来说，有对应的程序叫做cc1plus Objective-C是cc1obj Java 是 jc1 gcc 这个命令只是这些后台程序的包装 处理过程编译 (compilation) 的6个步骤 汇编(Assembly)执行命令1gcc -c hello.s -o hello.o 也可以直接进行编译 1gcc -c hello.c -o hello.o 查看汇编代码 1objdump -d -M intel -S test.o 处理过程 汇编器是将汇编代码转变成机器可以执行的指令 汇编过程只是根据汇编指令和机器指令的对照表一一翻译 没有复杂的语法 没有语义 也不需要做指令优化 每一个汇编语句几乎都对应一条机器指令 符号 (Symbol) 用来表示一个地址 这个地址可能是一段子程序(后来发展成函数)的起始地址， 也可以是一个变量的起始地址 链接(Linking) 链接的过程就是组装模块的过程 每个源代码模块独立地编译 然后按照须要将它们 组装 起来 链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。 从原理上来讲，链接器的工作就是把一些指令对其它符号地址的引用加以修正 处理过程 链接过程主要包括： 地址和空间分配(Address and Storage Allocation) 符号决议(Symbol Resolution) 重定位(Relocation) …… 静态链接的最基本的过程和作用 在编译器编译main.c的时候它并不知道foo函数的地址， 所以它暂时把这些调用foo的指令的目标地址搁置， 等待最后链接的时候由链接器去将这些指令的目标地址修正。 如果没有链接器，须要我们手工把每个调用foo的指令进行修正，则填入正确的foo函数地址。 当func.c模块被重新编译，foo函数的地址有可能改变时，那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。 使用链接器，你可以直接引用其它模块的函数和全局变量而无需知道它们的地址 链接器在链接的时候，会根据你所引用的符号foo，自动去相应的func.o模块查找foo的地址 然后将main.c模块中所有引用到foo的指令重新修正","categories":[{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"GCC 编译过程 - 编译 (Compilation) 的 6 个步骤","slug":"GCC/GCC 编译过程 - 编译 (Compilation) 的 6 个步骤","date":"2021-04-30T07:43:40.948Z","updated":"2021-04-30T07:49:31.272Z","comments":true,"path":"GCC/GCC 编译过程 - 编译 (Compilation) 的 6 个步骤/","link":"","permalink":"https://abcdoc-cn.github.io/GCC/GCC%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%20-%20%E7%BC%96%E8%AF%91%20(Compilation)%20%E7%9A%84%206%20%E4%B8%AA%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"编译 (Compilation) 的 6 个步骤词法分析 首先源代码程序被输入到扫描器(Scanner) 运用一种类似于有限状态机(Finite State Machine)的算法可以很轻松地将源代码的字符序列分割成一系列的记号(Token) 产生的记号分为几大类： 关键字 标识符 字面量(包含数字、字符串等) 特殊符号(如加号、等号) 可用工具： lex 语法分析 语法分析器(Grammar Parser)将对由扫描器产生的记号进行语法分析，从而产生语法树(Syntax Tree) 整个分析过程采用了上下文无关语法(Context-free Grammar)的分析手段 语法树就是以表达式(Expression)为节点的树 C语言的一个语句是一个表达式 复杂的语句是很多表达式的组合 语法分析阶段必须对表达式内容进行区分， 如果出现了表达式不合法， 比如各种括号不匹配、 表达式中缺少操作符等 编译器就会报告语法分析阶段的错误 可用工具： yacc 语义分析 由语义分析器(Semantic Analyzer)完成 判断语句是否真正有意义 如一个指针和一个浮点数做乘法运算是否合法等 编译器所能分析的语义是静态语义(Static Semantic) 静态语义是指在编译期可以确定的语义 静态语义通常包括声明和类型的匹配，类型的转换 比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点到整型转换的过程，语义分析过程中需要完成这个步骤 比如将一个浮点型赋值给一个指针的时候，语义分析程序会发现这个类型不匹配，编译器将会报错 与之对应的动态语义 (Dynamic Semantic) 就是只有在运行期才能确定的语义 比如将0作为除数是一个运行期语义错误 经过语义分析阶段以后，整个语法树的表达式都被标识了类型 如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点 源代码优化 往往在源代码级别会有一个优化过程，使用源码级优化器 (Source Code Optimizer) 不同的编译器中可能会有不同的定义或有一些其它的差异 源代码优化器往往将整个语法树转换成中间代码(Intermediate Code)， 它是语法树的顺序表示 一般跟目标机器和运行时环境是无关的 中间代码使得编译器可以被分为前端和后端 编译器前端负责产生机器无关的中间代码 编译器后端将中间代码转换成目标机器代码 这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端 代码生成 属于编译器后端 代码生成器(Code Generator) 将中间代码转换成目标机器代码 过程十分依赖于目标机器 因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等 目标代码优化 属于编译器后端 目标代码优化器(Target Code Optimizer) 对目标代码进行优化 比如选择合适的寻址方式 使用位移来代替乘法运算 删除多余的指令 ……","categories":[{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"PKCS 发布的 15 个标准","slug":"计算机网络/PKCS 发布的 15 个标准","date":"2021-04-28T04:45:38.000Z","updated":"2021-06-08T03:29:55.024Z","comments":true,"path":"计算机网络/PKCS 发布的 15 个标准/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/PKCS%20%E5%8F%91%E5%B8%83%E7%9A%84%2015%20%E4%B8%AA%E6%A0%87%E5%87%86/","excerpt":"","text":"PKCS 发布的 15 个标准 The Public-Key Cryptography Standards 由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准， 其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。 PKCS#1：RSA加密标准 PKCS#1定义了RSA公钥函数的基本格式标准，特别是数字签名。 它定义了数字签名如何计算，包括待签名数据和签名本身的格式； 它也定义了PSA公/私钥的语法。 PKCS#2涉及了RSA的消息摘要加密，这已被并入PKCS#1中。 PKCS#3：Diffie-Hellman密钥协议标准PKCS#3描述了一种实现Diffie- Hellman密钥协议的方法。 PKCS#4最初是规定RSA密钥语法的，现已经被包含进PKCS#1中。 PKCS#5：基于口令的加密标准PKCS#5描述了使用由口令生成的密钥来加密8位位组串并产生一个加密的8位位组串的方法。 PKCS#5可以用于加密私钥，以便于密钥的安全传输（这在PKCS#8中描述）。 PKCS#6：扩展证书语法标准PKCS#6定义了提供附加实体信息的X.509证书属性扩展的语法 （当PKCS#6第一次发布时，X.509还不支持扩展。这些扩展因此被包括在X.509中）。 PKCS#7：密码消息语法标准PKCS#7为使用密码算法的数据规定了通用语法，比如数字签名和数字信封。 PKCS#7提供了许多格式选项，包括未加密或签名的格式化消息、已封装（加密）消息、已签名消息和既经过签名又经过加密的消息。 PKCS#8：私钥信息语法标准PKCS#8定义了私钥信息语法和加密私钥语法，其中私钥加密使用了PKCS#5标准。 PKCS#9：可选属性类型PKCS#9定义了PKCS#6扩展证书、PKCS#7数字签名消息、PKCS#8私钥信息和PKCS#10证书签名请求中要用到的可选属性类型。 已定义的证书属性包括E-mail地址、无格式姓名、内容类型、消息摘要、签名时间、签名副本（counter signature）、质询口令字和扩展证书属性。 PKCS#10：证书请求语法标准PKCS#10定义了证书请求的语法。 证书请求包含了一个唯一识别名、公钥和可选的一组属性，它们一起被请求证书的实体签名（证书管理协议中的PKIX证书请求消息就是一个PKCS#10）。 PKCS#11：密码令牌接口标准PKCS#11或“Cryptoki”为拥有密码信息（如加密密钥和证书）和执行密码学函数的单用户设备定义了一个应用程序接口（API）。 智能卡就是实现Cryptoki的典型设备。 注意：Cryptoki定义了密码函数接口，但并未指明设备具体如何实现这些函数。而且Cryptoki只说明了密码接口，并未定义对设备来说可能有用的其他接口，如访问设备的文件系统接口。 PKCS#12：个人信息交换语法标准PKCS#12定义了个人身份信息（包括私钥、证书、各种秘密和扩展字段）的格式。 PKCS#12有助于传输证书及对应的私钥，于是用户可以在不同设备间移动他们的个人身份信息。 PDCS#13：椭圆曲线密码标准PKCS#13标准当前正在完善之中。 它包括椭圆曲线参数的生成和验证、密钥生成和验证、数字签名和公钥加密，还有密钥协定，以及参数、密钥和方案标识的ASN.1语法。 PKCS#14：伪随机数产生标准PKCS#14标准当前正在完善之中。 为什么随机数生成也需要建立自己的标准呢？PKI中用到的许多基本的密码学函数，如密钥生成和Diffie-Hellman共享密钥协商，都需要使用随机数。然而，如果“随机数”不是随机的，而是取自一个可预测的取值集合，那么密码学函数就不再是绝对安全了，因为它的取值被限于一个缩小了的值域中。因此，安全伪随机数的生成对于PKI的安全极为关键。 PKCS#15：密码令牌信息语法标准PKCS#15通过定义令牌上存储的密码对象的通用格式来增进密码令牌的互操作性。 在实现PKCS#15的设备上存储的数据对于使用该设备的所有应用程序来说都是一样的，尽管实际上在内部实现时可能所用的格式不同。 PKCS#15的实现扮演了翻译家的角色，它在卡的内部格式与应用程序支持的数据格式间进行转换。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Vditor 快捷键","slug":"常用工具/Vditor 快捷键","date":"2021-04-27T03:38:02.000Z","updated":"2021-06-07T02:32:32.772Z","comments":true,"path":"常用工具/Vditor 快捷键/","link":"","permalink":"https://abcdoc-cn.github.io/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Vditor%20%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"通用 名称 快捷键 备注 表情 :/⌘ E 标题 Ctrl H / ⌘ H 参见下文 粗体 Ctrl B / ⌘ B 斜体 Ctrl I / ⌘ I 删除线 Ctrl S / ⌘ S 链接 Ctrl K / ⌘ K 参见下文 无序列表 Ctrl L / ⌘ L 参见下文 有序列表 Ctrl O / ⌘ O 参见下文 任务列表 Ctrl J / ⌘ J 参见下文 引用 Ctrl ; / ⌘ ; 参见下文 分割线 Ctrl Shift H / ⌘ ⇧ H 代码块 Ctrl U / ⌘ U 参见下文 代码 Ctrl G / ⌘ G 元素前插入空块 Ctrl Shift B / ⌘ ⇧ B wysiwyg &amp; ir 模式 元素后插入空块 Ctrl Shift E / ⌘ ⇧ E wysiwyg &amp; ir 模式 表格 Ctrl M / ⌘ M 参见下文 撤销 Ctrl Z / ⌘ Z 重做 Ctrl Y / ⌘ Y 隐藏编辑器 Ctrl P / ⌘ P sv 模式 全屏 Ctrl ‘ / ⌘ ‘ 向上移动块元素 Ctrl Shift U / ⌘ ⇧ U wysiwyg &amp; ir 模式 向下移动块元素 Ctrl Shift D / ⌘ ⇧ D wysiwyg &amp; ir 模式 移除当前元素 Ctrl Shift X / ⌘ ⇧ X wysiwyg 模式 At 用户 @ 错误输入 Backspace 标题 Ctrl H / ⌘ H 名称 快捷键 变大 Ctrl + / ⌘ + 变小 Ctrl - / ⌘ - H1-H6 Ctrl Alt 1/2/3/4/5/6 / ⌘ ⌥ 1/2/3/4/5/6 弹出菜单 Ctrl H / ⌘ H 链接 Ctrl K / ⌘ K 名称 快捷键 输入框和元素之间切换 Alt Enter / ⌥ Enter 输入框之间切换 Tab 列表 Ctrl L/O/J / ⌘ L/O/J 名称 快捷键 备注 缩进 TabCtrl Shift I / ⌘ ⇧ I Tab: 光标需位于开头 反向缩进 Shift Tab / ⇧ TabCtrl Shift O / ⌘ ⇧ OEnter Shift Tab / ⇧ Tab: 光标需位于开头Enter: 需为空列表项 完成和待办之间切换 Ctrl Shift J / ⌘ ⇧ J 任务列表 引用 Ctrl ; / ⌘ ; 名称 快捷键 备注 在顶层引用前插入空块 Ctrl Alt Enter / ⌘ ⌥ Enter wysiwyg 模式 在顶层引用后插入空块 Alt Enter / ⌥ Enter wysiwyg 模式 插入块元素 Ctrl Shift : / ⌘ ⇧ : &gt; Ctrl Shift : / ⌘ ⇧ :: 块元素变为引用&gt;: 内联元素中插入引用 引用和块元素之间切换 Ctrl ; / ⌘ ; 代码块 Ctrl U / ⌘ U 名称 快捷键 输入框和代码块之间切换 Alt Enter / ⌥ Enter 隐藏编辑界面 Escape 选中所有代码 Ctrl A / ⌘ A 表格 Ctrl M / ⌘ M 名称 快捷键 在上方插入一行 Ctrl + / ⌘ ⇧ F 在下方插入一行 Ctrl + / ⌘ + 删除行 Ctrl - / ⌘ - 在左边插入一列 Ctrl Shift + / ⌘ ⇧ G 在右边插入一列 Ctrl Shift + / ⌘ ⇧ + 删除列 Ctrl Shift - / ⌘ ⇧ - 左对齐 Ctrl Shift L / ⌘ ⇧ L 中对齐 Ctrl Shift C / ⌘ ⇧ C 右对齐 Ctrl Shift R / ⌘ ⇧ R 光标移动到输入框中 Alt Enter / ⌥ Enter 输入框之间切换 Tab 将光标移动到上一个元素 Shift Tab / ⇧ TabBackspace 将光标移动到下一个元素 Tab","categories":[{"name":"前端","slug":"前端","permalink":"https://abcdoc-cn.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vditor","slug":"Vditor","permalink":"https://abcdoc-cn.github.io/tags/Vditor/"}]},{"title":"C 语言基本数据类型","slug":"C/C 语言基本数据类型","date":"2021-04-27T03:09:17.000Z","updated":"2021-06-09T09:37:00.000Z","comments":true,"path":"C/C 语言基本数据类型/","link":"","permalink":"https://abcdoc-cn.github.io/C/C%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"整数类型 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 浮点类型 类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位小数 double 8 字节 2.3E-308 到 1.7E+308 15 位小数 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位小数","categories":[{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"}],"author":"Abcdoc"},{"title":"MySQL 函数列表","slug":"MySQL/MySQL 函数列表","date":"2021-04-27T02:52:20.000Z","updated":"2021-06-07T02:30:23.324Z","comments":true,"path":"MySQL/MySQL 函数列表/","link":"","permalink":"https://abcdoc-cn.github.io/MySQL/MySQL%20%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8/","excerpt":"","text":"MySQL 数值型函数 函数名称 作 用 ABS 求绝对值 SQRT 求二次方根 MOD 求余数 CEIL 和 CEILING 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整 FLOOR 向下取整，返回值转化为一个BIGINT RAND 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列 ROUND 对所传参数进行四舍五入 SIGN 返回参数的符号 POW 和 POWER 两个函数的功能相同，都是所传参数的次方的结果值 SIN 求正弦值 ASIN 求反正弦值，与函数 SIN 互为反函数 COS 求余弦值 ACOS 求反余弦值，与函数 COS 互为反函数 TAN 求正切值 ATAN 求反正切值，与函数 TAN 互为反函数 COT 求余切值 MySQL 字符串函数 函数名称 作 用 LENGTH 计算字符串长度函数，返回字符串的字节长度 CONCAT 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个 INSERT 替换字符串函数 LOWER 将字符串中的字母转换为小写 UPPER 将字符串中的字母转换为大写 LEFT 从左侧字截取符串，返回字符串左边的若干个字符 RIGHT 从右侧字截取符串，返回字符串右边的若干个字符 TRIM 删除字符串左右两侧的空格 REPLACE 字符串替换函数，返回替换后的新字符串 SUBSTRING 截取字符串，返回从指定位置开始的指定长度的字符换 REVERSE 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串 MySQL 日期和时间函数 函数名称 作 用 CURDATE 和 CURRENT_DATE 两个函数作用相同，返回当前系统的日期值 CURTIME 和 CURRENT_TIME 两个函数作用相同，返回当前系统的时间值 NOW 和 SYSDATE 两个函数作用相同，返回当前系统的日期和时间值 UNIX_TIMESTAMP 获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数 FROM_UNIXTIME 将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数 MONTH 获取指定日期中的月份 MONTHNAME 获取指定日期中的月份英文名称 DAYNAME 获取指定曰期对应的星期几的英文名称 DAYOFWEEK 获取指定日期对应的一周的索引位置值 WEEK 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53 DAYOFYEAR 获取指定曰期是一年中的第几天，返回值范围是1~366 DAYOFMONTH 获取指定日期是一个月中是第几天，返回值范围是1~31 YEAR 获取年份，返回值范围是 1970〜2069 TIME_TO_SEC 将时间参数转换为秒数 SEC_TO_TIME 将秒数转换为时间，与TIME_TO_SEC 互为反函数 DATE_ADD 和 ADDDATE 两个函数功能相同，都是向日期添加指定的时间间隔 DATE_SUB 和 SUBDATE 两个函数功能相同，都是向日期减去指定的时间间隔 ADDTIME 时间加法运算，在原始时间上添加指定的时间 SUBTIME 时间减法运算，在原始时间上减去指定的时间 DATEDIFF 获取两个日期之间间隔，返回参数 1 减去参数 2 的值 DATE_FORMAT 格式化指定的日期，根据参数返回指定格式的值 WEEKDAY 获取指定日期在一周内的对应的工作日索引 MySQL 聚合函数 函数名称 作用 MAX 查询指定列的最大值 MIN 查询指定列的最小值 COUNT 统计查询结果的行数 SUM 求和，返回指定列的总和 AVG 求平均值，返回指定列数据的平均值 MySQL 流程控制函数 函数名称 作用 IF 判断，流程控制 IFNULL 判断是否为空 CASE 搜索语句","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/categories/MySQL/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/tags/MySQL/"}]},{"title":"C语言函数","slug":"C/C 语言函数","date":"2021-04-27T02:07:04.000Z","updated":"2021-06-04T09:49:09.691Z","comments":true,"path":"C/C 语言函数/","link":"","permalink":"https://abcdoc-cn.github.io/C/C%20%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/","excerpt":"","text":"C 语言函数字符测试函数 函数 说明 isascii() 判断字符是否为ASCII码字符 字符串操作函数 函数 说明 gcvt() 将浮点型数转换为字符串(四舍五入) index() 查找字符串并返回首次出现的位置 rindex() 查找字符串并返回最后一次出现的位置 strcasecmp() 判断字符串是否相等(忽略大小写) strcpy() 复制字符串 strncpy() 把源字符串的字符复制到目标数组 总是复制len个字符到dst指向的内存：如果strlen(src)的值小于len，dst数组就用额外的NUL字节填充到len长度；如果strlen(src)的值大于或等于len，那么只有len个字符被复制到dst中。如果len&gt;strlen(dst)，那么会破坏dst后面的内存注意！它的结果将不会以NUL字节结尾。（NUL即‘\\0’） strdup() 复制字符串 strncasecmp() 比较字符串的前n个字符 内存控制函数 函数 说明 getpagesize() 取得内存分页大小 mmap() 建立内存映射 munmap() 解除内存映射 memccpy() 复制内存中的内容 memchr() 在内存中查找特定字符 memcmp() 比较内存前n个字节 日期时间函数 函数 说明 asctime() 将时间日期以字符串格式表示 ctime() 将时间日期以字符串格式表示 gettimeofday() 获取当前时间 gmtime() 获取当前时间和日期 localtime() 获取当前时间和日期并转换为本地时间 mktime() 将时间转换成经过的秒数 settimeofday() 设置当前时间戳 time() 获取当前时间(以秒数表示) 数学函数 函数 说明 abs() 求绝对值(整数) asin() 求反正弦的值(以弧度表示) atan() 求反正切的值(以弧度表示) atan2() 求反正切的值(以弧度表示) ceil() 向上取整 文件读写函数 函数 说明 endgrent() 关闭文件(关闭组文件) endpwent() 关闭文件(关闭密码文件) endutent() 关闭文件(关闭utmp文件) fgetgrent() 读取组格式函数 fgetpwent() 读取密码格式 getegid() 获得组识别码 geteuid() 获取用户识别码函数 getgid() 取得组识别码函数 getgrent() 从组文件中取得账号的数据 getgrgid() 从组文件中取得指定gid的数据 getgrnam() 从组文件中取得指定组的数据 getgroups() 获取组代码函数 getpw() 取得指定用户的密码文件数据 getpwent() 从密码文件中取得账号的数据 getpwnam() 从密码文件中取得指定账号的数据 getpwuid() 从密码文件中取得指定uid的数据 getuid() 取得真实的用户识别码 getutent() 从utmp文件中取得账号登录数据 getutid() 从utmp文件中查找特定的记录 getutline() 文件查找函数(从utmp文件中查找特定的 initgroups() 初始化组清单 pututline() 将utmp记录写入文件 seteuid() 设置有效的用户识别码 setfsgid() 设置文件系统的组识别码 setfsuid() 设置文件系统的用户识别码 setgid() 设置真实的组识别码 setgrent() 从头读取组文件中的组数据 setgroups() 设置组代码函数 setpwent() 从头读取密码文件中的账号数据 setregid() 设置真实及有效的组识别码 setreuid() 设置真实及有效的用户识别码 setuid() 设置真实的用户识别码 setutent() 从头读取utmp文件中的登录数据 utmpname() 设置文件路径 close() 关闭文件 creat() 创建文件函数 dup() 复制文件描述词 dup2() 复制文件描述词 fcntl() 文件描述词操作函数 flock() 解除锁定文件 fsync() 将缓冲区数据写回磁盘 lseek() 移动文件的读写位置 mkstemp() 建立临时文件 open() 打开文件函数 read() 读文件函数(由已打开的文件读取数据) sync() 写文件函数(将缓冲区数据写回磁盘) write() 写文件函数 clearerr() 清除文件流的错误旗标 fclose() 关闭打开的文件 fdopen() 将文件描述词转为文件指针 feof() 检查文件流是否读到了文件尾 fflush() 更新缓冲区 fgetc() 读文件函数(由文件中读取一个字符) fgets() 读取文件字符串 fileno() 获取文件流所使用的文件描述词 fputc() 写文件函数(将一指定字符写入文件流中) fputs() 写文件函数(将一指定的字符串写入文件 fread() 读文件函数(从文件流读取数据) freopen() 打开文件函数，并获得文件句柄 fseek() 移动文件流的读写位置 ftell() 取得文件流的读取位置 fwrite() 写文件函数(将数据流写入文件中) mktemp() 产生唯一临时文件名 setbuffer() 设置文件流的缓冲区 setlinebuf() 设置文件流为线性缓冲区 进程管理函数 函数 说明 atexit() 设置程序正常结束前调用的函数 execl() 执行文件函数 execlp() 从PATH 环境变量中查找文件并执行 execv() 执行文件函数 execve() 执行文件函数 execvp() 执行文件函数 exit() 结束进程 _exit() 结束进程执行 getpgid() 获取进程组识别码 getpgrp() 获取进程组识别码 getpid() 获取进程识别码 getppid() 取得父进程的进程识别码 getpriority() 取得程序进程执行优先权 nice() 改变进程优先顺序 on_exit() 设置程序正常结束前调用的函数 setpgid() 设置进程组识别码函数 setpgrp() 设置进程组识别码 setpriority() 设置程序进程执行优先权 system() 执行shell命令 wait() 结束(中断)进程函数(常用) waitpid() 中断(结束)进程函数(等待子进程中断或 fprintf() 输出函数(格式化输出数据至文件) fscanf() 输入函数(比较常用) sacnf() 字符串输入函数(最常用的输入函数) vfprintf() 输出函数(格式化输出数据至文件) vfscanf() 输入函数(先格式化字符串再输入) vprintf() 输出函数 vscanf() 字符串格式化输入函数 vsprintf() 格式化字符串 vsscanf() 字符串输入函数 vfork() 建立新的进程 文件权限控制函数 函数 说明 access() 判断是否具有存取文件的权限 alphasort() 依字母顺序排序目录结构 chdir() 改变当前的工作目录 chmod() 修改文件权限 chown() 改变文件所有者 chroot() 改变文件根目录 closedir() 关闭目录 fchdir() 改变当前工作目录 fchmod() 修改文件的权限 fchown() 改变文件的所有者 fstat() 由文件描述词取得文件状态 ftruncate() 改变文件大小 getcwd() 取得当前的工作目录 link() 建立文件连接 lstat() 由文件描述词取得文件状态 opendir() 打开目录函数 readdir() 读取目录函数 readlink() 取得符号连接所指的文件 rewinddir() 重设读取目录的位置为开头位置 seekdir() 设置下回读取目录的位置 stat() 获取文件状态 symlink() 建立文件符号连接 telldir() 取得目录流的读取位置 truncate() 改变文件大小 umask() 设置建立新文件时的权限遮罩 unlink() 删除文件 utime() 修改文件的存取时间和更改时间 utimes() 修改文件的存取时间和更改时间 信号处理函数 函数 说明 alarm() 设置信号传送闹钟 kill() 传送信号给指定的进程 pause() 让进程暂停直到信号出现 sigaddset() 增加一个信号至信号集 sigdelset() 从信号集里删除一个信号 sigemptyset() 初始化信号集 sigfillset() 将所有信号加入至信号集 sigismember() 测试某个信号是否已加入至信号 signal() 设置信号处理方式 sigpending() 查询被搁置的信号 sigprocmask() 查询或设置信号遮罩 sleep() 让进程暂停执行一段时间 ferror() 检查文件流是否有错误发生 strerror() 返回错误原因的描述字符串 mkfifo() 建立具名管道 pclose() 关闭管道I/O popen() 建立管道I/O sigaction() 查询或设置信号处理方式 接口处理函数 函数 说明 accept() 接受socket连线 bind() 对socket定位 connect() 建立socket连线 endprotoent() 结束网络协议数据的读取 endservent() 结束网络服务数据的读取 getsockopt() 取得socket 状态 htonl() 将32位主机字符顺序转换成网络字符顺序 htons() 将16位主机字符顺序转换成网络字符顺序 inet_addr() 将网络地址转成二进制的数字 inet_aton() 将网络地址转成网络二进制的数字 inet_ntoa() 将网络二进制的数字转换成网络地址 listen() 等待连接 ntohl() 将32位网络字符顺序转换成主机字符顺序 ntohs() 将16位网络字符顺序转换成主机字符顺序 recv() 经socket接收数据 recvfrom() 经socket接收数据 recvmsg() 经socket接收数据 send() 经socket传送数据 sendmsg() 经socket传送数据 sendto() 经socket传送数据 setprotoent() 打开网络协议的数据文件 setsockopt() 设置socket状态 shutdown() 终止socket通信 socket() 建立一个socket通信 setservent() 打开主机网络服务的数据文件 环境变量函数 函数 说明 getenv() 取得环境变量内容 putenv() 改变或增加环境变量 终端控制函数 函数 说明 getopt() 分析命令行参数 isatty() 判断文件描述词是否是为终端机 select() I/O多工机制 ttyname() 返回一终端机名称","categories":[{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"}]},{"title":"MySQL 重置 ROOT 密码","slug":"MySQL/MySQL 重置 ROOT 密码","date":"2021-04-26T09:21:02.000Z","updated":"2021-06-07T02:30:46.980Z","comments":true,"path":"MySQL/MySQL 重置 ROOT 密码/","link":"","permalink":"https://abcdoc-cn.github.io/MySQL/MySQL%20%E9%87%8D%E7%BD%AE%20ROOT%20%E5%AF%86%E7%A0%81/","excerpt":"","text":"Windows 打开 DOS 窗口，转到 mysql\\bin 目录 输入 mysqld --skip-grant-tables 回车。如果没有出现提示信息，那就对了 新开一个 DOS 窗口，保留之前的 DOS 窗口 输入 mysql 回车，成功会出现 MySQL 提示符 1234567891011## 连接权限数据库mysql&gt; use mysql;## 修改密码mysql&gt; update user set password=password(&quot;111111&quot;) where user=&quot;root&quot;;## 刷新权限mysql&gt; flush privileges;## 退出msyql&gt; \\q 注销系统，重新进入，可以使用新的密码登陆 mysql Linux 先登陆服务器，找到自己的 my.cnf 文件 一般在 /etc 目录下 如果不在，可以用 find / -name my.cnf 命令找一下 vi my.cnf 命令编辑该文件 在[mysqld]下面加上 skip-grant-tables，作用是登陆时跳过登陆认证 用 service mysqld restart 重启mysql 重置密码 12345678910111213# mysql -uroot -p## 连接权限数据库mysql&gt; use mysql;## 修改密码mysql&gt; update user set password=password(&#x27;111111&#x27;) where user=&#x27;root&#x27;;## 刷新权限mysql&gt; flush privileges;## 退出msyql&gt; \\q 删除 my.cnf 中添加的 skip-grant-tables 重启 mysql","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/categories/MySQL/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/tags/MySQL/"}]},{"title":"Node.js 使用 淘宝镜像","slug":"Nodejs/Node.js 使用 淘宝镜像","date":"2021-04-26T02:21:07.000Z","updated":"2021-06-07T02:33:35.258Z","comments":true,"path":"Nodejs/Node.js 使用 淘宝镜像/","link":"","permalink":"https://abcdoc-cn.github.io/Nodejs/Node.js%20%E4%BD%BF%E7%94%A8%20%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F/","excerpt":"","text":"淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10 分钟一次以保证尽量与官方服务同步。 方法一 - 使用 cnpm你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用 cnpm 命令来安装模块了： 1$ cnpm install [name] 方法二 - 添加配置执行以下命令： 1$ npm config set registry https://registry.npm.taobao.org 删除配置： 1$ npm config delete registry","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://abcdoc-cn.github.io/categories/Nodejs/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"nodejs","slug":"nodejs","permalink":"https://abcdoc-cn.github.io/tags/nodejs/"}]},{"title":"Node.js 设置代理","slug":"Nodejs/Node.js 设置代理","date":"2021-04-26T01:26:05.000Z","updated":"2021-06-07T02:33:19.563Z","comments":true,"path":"Nodejs/Node.js 设置代理/","link":"","permalink":"https://abcdoc-cn.github.io/Nodejs/Node.js%20%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"设置代理123npm config set https-proxy=http://用户名:密码@代理地址:代理端口/npm config set proxy=http://用户名:密码@代理地址:代理端口/npm config set strict-ssl false 删除代理123npm config delete proxynpm config delete http","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://abcdoc-cn.github.io/categories/Nodejs/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"nodejs","slug":"nodejs","permalink":"https://abcdoc-cn.github.io/tags/nodejs/"}]},{"title":"TCP 四次挥手","slug":"计算机网络/TCP 四次挥手","date":"2021-04-25T08:12:46.825Z","updated":"2021-04-27T03:39:01.320Z","comments":true,"path":"计算机网络/TCP 四次挥手/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"","text":"四次挥手断开连接要进行四次，这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的（即数据可在两个方向上同时传递），所以进行关闭时每个方向上都要单独进行关闭，这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。 进行关闭的一方执行主动关闭，另一方执行被动关闭。 第一次挥手： 客户端发起 FIN 包（FIN=1），客户端进入 FIN_WAIT_1 状态 FIN = 1，TCP 规定，即使 FIN 包不携带数据，也要消耗一个序号 seq = u 第二次挥手：服务端收到 FIN 包，发出确认包 ACK，服务端进入 CLOSE_WAIT 状态， ACK = 1 seq = v ack=u + 1 此时客户端已经没有数据需要发送了 服务端如果有数据发送的话，客户端仍然需要接收 客户端收到 ACK 进入 FIN_WAIT_2 状态 第三次挥手： 服务端数据发送完毕，发出 FIN 包，服务端进入 LAST_ACK 状态 FIN = 1 seq = w ack = u + 1 第四次挥手：客户端收到 FIN 包，发出确认包 ACK，客户端进入 TIME_WAIT 状态 ACK = 1 seq = u + 1 ack = w + 1 此时客户端的 TCP 连接还没有释放，必须经过 2 * MSL 后，才进入 CLOSED 状态 服务端收到 ACK 后进入 CLOSED 状态 四次挥手的必要性 TCP 是全双工通信， 三次握手实际是将 ACK 和 SYN 合并到一个包，减少一次包的发送 四次挥手主动关闭方发送 FIN 时，接收端可能还要发送数据，不能立即关闭数据通道， 也就不能将服务端的 FIN 包和客户端的 ACK 包合并发送， 只能先确认 ACK， 然后服务端无需发送数据时，再发送 FIN 2MSL 说明 MSL 指的是报文在网络中最大生存时间 客户端发送对服务端的 FIN 的确认包**ACK 包是有可能不可达的**， 服务端如果没有收到 ACK ，需要重新发送 FIN 包 客户端发送 ACK 后需要留出 2MSL 时间等待服务端收取 ACK 包 ACK 到达服务器 + 服务器重新发送 FIN 包，一个来回的时间 如果客户端 2MSL 未收到服务器的重传包 FIN，默认服务器收到了 ACK 延时 2MSL，也可避免新旧连接混淆 经过 2MSL 时间，可以使本连接持续时间内产生的所有报文从网络中消失","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://abcdoc-cn.github.io/tags/TCP-IP/"}]},{"title":"TCP 套接字的状态","slug":"计算机网络/TCP 套接字状态","date":"2021-04-25T08:12:46.825Z","updated":"2021-04-27T03:39:01.320Z","comments":true,"path":"计算机网络/TCP 套接字状态/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%8A%B6%E6%80%81/","excerpt":"","text":"TCP 套接字的所有状态及说明实际上就是 TCP 的三次握手和四次挥手的所有状态 状态 描述 数据 LISTEN 服务端侦听套接字 等待客户端的连接 SYN-SENT 客户端已发送套接字连接请求报文 等待连接被服务器接收 SYN-RECEIVED 服务器端接收连接请求报文后，等待客户端的确认连接的回复报文 等待客户端的确认连接的回复报文 ESTABLISHED 服务端和客户端之间成功建立了一条有效的连接，可以互相传输数据 可以互相传输数据 FIN-WAIT-1 服务器或客户端调用 close 函数主动向对方发出终止连接的请求报文,同时等待对方确认终止连接的回复报文 等待对方确认终止连接的回复报文 FIN-WAIT-2 主动关闭连接端收到对方确认终止连接的回复报文，同时等待对方连接终止的请求报文，这时的状态是 TCP 连接的半关闭状态，可以接受数据，但是不能发送数据 等待对方连接终止的请求报文 CLOSE-WAIT 被动关闭端收到主动关闭端终止连接的请求报文后，向主动关闭端发送确认终止连接的回复报文，同时被动关闭端等待本地用户终止连接，这时被动关闭端的状态是 TCP 连接的半关闭状态，可以发送数据，但是不能接收数据 等待本地用户终止连接 CLOSING 服务器和客户端同时向对方发送终止连接(调用close函数)请求报文,并且双方都是在收到对方发送的终止连接回复报文之前收到了对方的发送的终止连接请求报文，这个时候双方都进入了 CLOSING 状态，进入 CLOSING 状态之后,只要收到了对方对自己终止连接的回复报文，就会进入 TIME-WAIT 状态，所以 CLOSING 状态的持续时间会特别短,一般很难捕获到 LAST-ACK 被动关闭端发送完全部数据之后,向主动关闭端发送终止连接的请求报文 等待主动关闭端发送终止连接的回复报文 TIME-WAIT 主动关闭端收到被动关闭端终止连接的请求报文后，给被动关闭端发送终止连接的回复报文,等待足够时间以确保被动关闭端收到了主动关闭端发送的终止连接的回复报文 等待足够时间 CLOSED 完全没有连接，套接字连接已经终止了","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://abcdoc-cn.github.io/tags/TCP-IP/"}]},{"title":"TCP 数据包","slug":"计算机网络/TCP 数据包","date":"2021-04-25T08:12:46.825Z","updated":"2021-04-27T03:39:01.320Z","comments":true,"path":"计算机网络/TCP 数据包/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E6%95%B0%E6%8D%AE%E5%8C%85/","excerpt":"","text":"TCP 数据包 源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。 目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。 顺序号 seq（ 32 位）：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2 的 32 次方 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）。 确认号 ack（ 32 位）：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。 TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。 保留位（ 6 位）：保留给将来使用，目前必须置为 0 。 控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为： URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。 ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。 PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。 ** ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。 SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。 FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。 窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。 校验和（ 16 位）：此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。 紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项， 它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。 数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://abcdoc-cn.github.io/tags/TCP-IP/"}]},{"title":"TCP 三次挥手","slug":"计算机网络/TCP 三次握手","date":"2021-04-25T08:12:46.000Z","updated":"2021-06-07T01:56:19.973Z","comments":true,"path":"计算机网络/TCP 三次握手/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"三次握手 TCP 连接的本质就是双方各自维护所需的状态，并非是在通信设备两端建立信号隧道 第一次握手：客户端发送 SYN 包（SYN=1）到服务端，并进入 SYN_SENT 状态，等待服务端确认 SYN＝1，服务端由 SYN=1 知道，A 要求建立联机 随机产生 seq number=1234567 的数据包； 第二次握手：服务端收到 SYN 请求，需要给客户端发送 ACK 确认报文，同时服务端也要向客户端发送一个 SYN 报文，即服务端发送给客户端的是 SYN + ACK 报文，此时服务端进入 SYN_RCVD 状态 SYN=1 ACK=1 随机产生 seq=7654321 的包， 向 A 发送 ack number=(主机 A 的 seq+1), 第三次握手：客户端收到 SYN + ACK 报文后，向服务端发送确认报文 ACK， 客户端端进入 ESTABLISHED 状态 收到后检查 ack number 是否正确，即第一次发送的 seq number+1, 检查位码ack 是否为 1， 若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1， 服务端收到 ACK 请求，进入 ESTABLISHED 状态 确认 seq 值与 ack=1 则连接建立成功 SYN （Synchronous）： 同步的，表示建立同步连接 ACK （Acknowledge）：确认 Seq （Sequence）： 序列 FIN （Finish）： 完成 Sequence Number 是记录包的序号， TCP 会按照报文字节进行编号， 用来解决包在网络中乱序的问题 Acknowledgement Number 确认序列号， 用于向发送方确认已经收到了哪些包， 用来解决不丢包的问题 三次握手的必要性确认双发的收发能力 第一次握手：客户端发包，服务端收包，服务端确认：客户端发送能力、服务端接收能力正常 第二次握手：服务端发包，客户端收包，客户端确认：服务端发送能力、接收能力、客户端发送能力、接收能力正常 第三次握手：客户端发包，服务端收包，服务端确认：客户端发送能力、接收能力正常 序列号可靠同步 两次握手，服务端无法确定客户端是否已接收了自己发送的初始序列号 阻止历史连接初始化 服务端回复 SYN+ACK后，客户端会对比应答的序号，如果是旧的报文会给服务端发送 RST 报文，直到最新的 SYN 到达服务器才正常建立连接 三次握手有足够的上下文判断当前连接是否为历史连接 安全问题 防 DDOS 攻击：如果两次握手就建立连接，新建连接时，内核会分配很多的内存资源 初始序列号（ISN） Initial Sequence Number TCP 发送方的字节数据编号的原点 动态生成 如果固定，攻击者很容易猜出后续的确认序号，发送伪造的 RST 报文 半连接队列 服务器收到第一次握手的 SYN，会处于 SYN_RCVD 状态，并把请求连接放到一个队列，这个队列就是半连接队列 全连接队列 服务器收到第三次握手连接建立成功，会将连接放到全连接队列中 如果全连接队列满了，可能会出现丢包现象 第三次握手可以携带数据 如果第一次握手可以携带数据，那么可能会给服务器造成恶意功能，服务器需要花费大量内存空间缓存 SYN 报文 第三次握手，客户端已处于连接状态，且确认服务端接收发送能力正常，可以携带数据","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://abcdoc-cn.github.io/tags/TCP-IP/"}]},{"title":"TCP/IP 协议","slug":"计算机网络/TCPIP 协议","date":"2021-04-25T08:12:46.000Z","updated":"2021-06-07T01:57:18.026Z","comments":true,"path":"计算机网络/TCPIP 协议/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPIP%20%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"[TOC] TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。 从协议分层模型方面来看，TCP/IP 由四个层次组成： 网络访问层（Network Access Layer） 网络层（Internet Layer） 传输层（Transport Layer - TCP/UDP） 应用层（Application Layer） TCP 在传输之前会进行三次沟通，一般称为三次握手，传完数据断开的时候要进行四次沟通，一般称为四次挥手","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络 7 层架构","slug":"计算机网络/计算机网络 7 层架构","date":"2021-04-25T08:05:42.000Z","updated":"2021-06-08T03:26:57.556Z","comments":true,"path":"计算机网络/计算机网络 7 层架构/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%207%20%E5%B1%82%E6%9E%B6%E6%9E%84/","excerpt":"","text":"[TOC] 物理层定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。 作用： 传输比特流，由1、0转化为电流强弱进行传输，到达目的地转化为1、0（模数转换） 数据： 比特 数据链路层 作用： 将物理层接收的数据进行 MAC 地址（网卡地址）的封装与解封装 为 IP 模块发送和接收 IP 数据报 为 ARP 模块发送ARP 请求和接收 ARP 应答 ARP 叫做地址解析协议，是用IP地址换MAC地址的一种协议 为 RARP 发送 RARP 请求和接收 RARP 应答 RARP 叫做逆地址解析协议 数据： 帧 设备： 交换机 点对点协议（PPP） 提供了一种低速接入的解决方案 环回接口（loopback） 用 127.0.0.1 连接本机，走的就是 loopback 接口 传给环回地址（一般是127.0.0.1）的任何数据均作为 IP 输入 传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上 因为广播传送和多播传送的定义包含主机本身 任何传给该主机 IP 地址的数据均送到环回接口 网络层 作用： 将从下层接收的数据进行 IP 地址的封装与解封装 数据： 数据包 设备： 路由器 传输层 作用：将从下层接收的数据进行分段传输，到达目的地址后进行重组 数据： 段 定义一些传输数据的协议和端口号，比如： TCP： 传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高、数据量大的数据 UDP： 用户数据报协议，用于传输可靠性要求不高、数据量小的数据 会话层通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，在系统之间发起会话或者接收会话请求。 表示层 作用： 对接收的数据进行解释、加密与解密、压缩与解压缩等，就是将计算机能识别的东西转换成人能识别的东西 应用层主要是一些终端的应用，比如： FTP，WEB，QQ 之类","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Typora 标题自动添加序列号","slug":"常用工具/Typora 标题自动添加序列号","date":"2021-04-25T07:58:53.321Z","updated":"2021-04-28T04:37:31.719Z","comments":true,"path":"常用工具/Typora 标题自动添加序列号/","link":"","permalink":"https://abcdoc-cn.github.io/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Typora%20%E6%A0%87%E9%A2%98%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%88%97%E5%8F%B7/","excerpt":"","text":"文件 -&gt; 偏好设置 新建文件 base.user.css 添加内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328/*************************************** Header Counters in TOC**************************************//* No link underlines in TOC*/.md-toc-inner &#123; text-decoration: none;&#125;.md-toc-content &#123; counter-reset: h1toc h2toc h3toc h4toc h5toc h6toc&#125;.md-toc-h1 &#123; margin-left: 0; font-size: 1.5rem; counter-reset: h2toc&#125;.md-toc-h2 &#123; font-size: 1.1rem; margin-left: 2rem; counter-reset: h3toc&#125;.md-toc-h3 &#123; margin-left: 3rem; font-size: .9rem; counter-reset: h4toc&#125;.md-toc-h4 &#123; margin-left: 4rem; font-size: .85rem; counter-reset: h5toc&#125;.md-toc-h5 &#123; margin-left: 5rem; font-size: .8rem; counter-reset: h6toc&#125;.md-toc-h6 &#123; margin-left: 6rem; font-size: .75rem;&#125;.md-toc-h2:before &#123; color: black; counter-increment: h2toc; content: counter(h2toc) &quot;. &quot;&#125;.md-toc-h2 ~ .md-toc-h3:before &#123; color: black; counter-increment: h3toc; content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot;&#125;.md-toc-h2 ~ .md-toc-h4:before &#123; color: black; counter-increment: h4toc; content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot;&#125;.md-toc-h2 ~ .md-toc-h5:before &#123; color: black; counter-increment: h5toc; content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot;&#125;.md-toc-h2 ~ .md-toc-h6:before &#123; color: black; counter-increment: h6toc; content: counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; counter(h6toc) &quot;. &quot;&#125;.md-toc-h1:before &#123; color: black; counter-increment: h1toc; content: counter(h1toc) &quot;. &quot;&#125;.md-toc-h1 ~ .md-toc-h2:before &#123; color: black; counter-increment: h2toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot;&#125;.md-toc-h1 ~ .md-toc-h3:before &#123; color: black; counter-increment: h3toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot;&#125;.md-toc-h1 ~ .md-toc-h4:before &#123; color: black; counter-increment: h4toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot;&#125;.md-toc-h1 ~ .md-toc-h5:before &#123; color: black; counter-increment: h5toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot;&#125;.md-toc-h1 ~ .md-toc-h6:before &#123; color: black; counter-increment: h6toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; counter(h6toc) &quot;. &quot;&#125;.md-toc-h1 .md-toc-inner &#123; margin-left: 0;&#125;.md-toc-h2 .md-toc-inner &#123; margin-left: 0;&#125;.md-toc-h3 .md-toc-inner &#123; margin-left: 0;&#125;.md-toc-h4 .md-toc-inner &#123; margin-left: 0;&#125;.md-toc-h5 .md-toc-inner &#123; margin-left: 0;&#125;.md-toc-h6 .md-toc-inner &#123; margin-left: 0;&#125;/*************************************** Header Counters in Content**************************************//** initialize css counter*/#write &#123; counter-reset: h1 h2 h3 h4 h5 h6&#125;h1 &#123; counter-reset: h2&#125;h2 &#123; counter-reset: h3&#125;h3 &#123; counter-reset: h4&#125;h4 &#123; counter-reset: h5&#125;h5 &#123; counter-reset: h6&#125;/** put counter result into headings*/#write h2:before &#123; counter-increment: h2; content: counter(h2) &quot;. &quot;&#125;#write h2 ~ h3:before, h2 ~ h3.md-focus.md-heading:before &#123; /*override the default style for focused headings*/ counter-increment: h3; content: counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;&#125;#write h2 ~ h4:before, h2 ~ h4.md-focus.md-heading:before &#123; counter-increment: h4; content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;&#125;#write h2 ~ h5:before, h2 ~ h5.md-focus.md-heading:before &#123; counter-increment: h5; content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;&#125;#write h2 ~ h6:before, h2 ~ h6.md-focus.md-heading:before &#123; counter-increment: h6; content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;&#125;#write h1:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot;&#125;#write h1 ~ h2:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot;&#125;#write h1 ~ h3:before, h1 ~ h3.md-focus.md-heading:before &#123; /*override the default style for focused headings*/ counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;&#125;#write h1 ~ h4:before, h1 ~ h4.md-focus.md-heading:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;&#125;#write h1 ~ h5:before, h1 ~ h5.md-focus.md-heading:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;&#125;#write h1 ~ h6:before, h1 ~ h6.md-focus.md-heading:before &#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;&#125;/** override the default style for focused headings*/#write&gt;h3.md-focus:before, #write&gt;h4.md-focus:before, #write&gt;h5.md-focus:before, #write&gt;h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before &#123; color: inherit; border: inherit; border-radius: inherit; position: inherit; left: initial; float: none; top: initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit;&#125;/*************************************** Header Counters in sidebar**************************************/.sidebar-content &#123; counter-reset: h1 h2 h3 h4 h5 h6&#125;.outline-h1 &#123; counter-reset: h2&#125;.outline-h2 &#123; counter-reset: h3&#125;.outline-h3 &#123; counter-reset: h4&#125;.outline-h4 &#123; counter-reset: h5&#125;.outline-h5 &#123; counter-reset: h6&#125;.outline-h2&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h2; content: counter(h2) &quot;. &quot;&#125;.outline-h2 ~ .outline-h3&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h3; content: counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;&#125;.outline-h2 ~ .outline-h4&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h4; content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;&#125;.outline-h2 ~ .outline-h5&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h5; content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;&#125;.outline-h2 ~ .outline-h6&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h6; content: counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;&#125;.outline-h1&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h1; content: counter(h1) &quot;. &quot;&#125;.outline-h1 ~ .outline-h2&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot;&#125;.outline-h1 ~ .outline-h3&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;&#125;.outline-h1 ~ .outline-h4&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;&#125;.outline-h1 ~ .outline-h5&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;&#125;.outline-h1 ~ .outline-h6&gt;.outline-item&gt;.outline-label:before &#123; counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;&#125; 重启 Typora","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://abcdoc-cn.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Typora","slug":"Typora","permalink":"https://abcdoc-cn.github.io/tags/Typora/"}]},{"title":"设计模式","slug":"设计模式/设计模式","date":"2021-04-25T06:16:42.115Z","updated":"2021-04-25T06:31:20.384Z","comments":true,"path":"设计模式/设计模式/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"[TOC] 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 创建型模式关注怎样创建对象用于描述怎样创建对象，主要特点是将对象的创建与使用分离。提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 在所有的工厂模式中： 两个类 A 和 B 之间的关系应该仅仅是 A 创建 B 或者 A 使用 B，不能两种关系都有 将对象的创建和使用分离，是的系统更加符合单一职责原则。 简单工厂模式（Simple Factory）不属于 23 个经典设计模式，是其他工厂模式的基础 客户端需要什么，只需传入一个正确的参数，就可以获取你所需要的对象，无须知道创建细节。 对象相关的职责有三类： 对象本身具有的职责 对象本身所具有的一些数据和行为，可以通过一些公开的方法实现它的职责 创建对象的职责 使用对象的职责 创建对象的几种方法： 使用 new 关键字 通过反射机制创建 通过 clone() 方法创建 通过工厂类创建 定义定义一个工厂类，它可以根据参数的不同返回不同的实例，被创建的实例通常都具有共同的父类。因为创建的实例方法都是静态方法，因此简单工厂模式又被称为静态工厂方法模式。 结构图 Factory（工厂角色）： 简单工厂模式的核心， 负责实现所有产品实例的内部逻辑 可以被外界直接调用，创建所需的产品对象 提供静态的工厂方法 factoryMethod()，返回类型是抽象产品类型（Product） Product（抽象产品角色）： 工厂类创建的所有对象的父类 封装各种产品对象的公有方法，它的引入提高系统灵活性，使工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct（具体产品角色）： 简单工厂模式的创建目标， 所有被创建的对象都充当了这个角色的某个具体类的实例 每个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法 客户端： 客户端通过工厂类创建一个产品类的实例，无需直接使用 new 类创建对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 抽象产品类abstract class Product &#123; //所有产品类的公共业务方法 public void methodSame() &#123; //公共方法的实现 &#125; //声明抽象业务方法 public abstract void methodDiff();&#125;// 具体产品类 Aclass ConcreteProductA extends Product &#123; //实现业务方法 public void methodDiff() &#123; //业务方法的实现 &#125;&#125;// 具体产品类 Bclass ConcreteProductB extends Product &#123; //实现业务方法 public void methodDiff() &#123; //业务方法的实现 &#125;&#125;// 工厂类class Factory &#123; //静态工厂方法 public static Product getProduct(String arg) &#123; Product product = null; if (arg.equalsIgnoreCase(&quot;A&quot;)) &#123; product = new ConcreteProductA(); //初始化设置product &#125; else if (arg.equalsIgnoreCase(&quot;B&quot;)) &#123; product = new ConcreteProductB(); //初始化设置product &#125; return product; &#125;&#125;// 客户端class Client &#123; public static void main(String args[]) &#123; Product product; product = Factory.getProduct(&quot;A&quot;); //通过工厂类创建产品对象 product.methodSame(); product.methodDiff(); &#125;&#125; 实例 抽象产品类： Chart 接口 具体产品类： HistogramChart、 PieChart、 LineChart 工厂类： ChartFactory 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//抽象图表接口：抽象产品类interface Chart &#123; public void display();&#125; //柱状图类：具体产品类class HistogramChart implements Chart &#123; public HistogramChart() &#123; System.out.println(&quot;创建柱状图！&quot;); &#125; public void display() &#123; System.out.println(&quot;显示柱状图！&quot;); &#125;&#125; //饼状图类：具体产品类class PieChart implements Chart &#123; public PieChart() &#123; System.out.println(&quot;创建饼状图！&quot;); &#125; public void display() &#123; System.out.println(&quot;显示饼状图！&quot;); &#125;&#125; //折线图类：具体产品类class LineChart implements Chart &#123; public LineChart() &#123; System.out.println(&quot;创建折线图！&quot;); &#125; public void display() &#123; System.out.println(&quot;显示折线图！&quot;); &#125;&#125; //图表工厂类：工厂类class ChartFactory &#123; //静态工厂方法 public static Chart getChart(String type) &#123; Chart chart = null; if (type.equalsIgnoreCase(&quot;histogram&quot;)) &#123; chart = new HistogramChart(); System.out.println(&quot;初始化设置柱状图！&quot;); &#125; else if (type.equalsIgnoreCase(&quot;pie&quot;)) &#123; chart = new PieChart(); System.out.println(&quot;初始化设置饼状图！&quot;); &#125; else if (type.equalsIgnoreCase(&quot;line&quot;)) &#123; chart = new LineChart(); System.out.println(&quot;初始化设置折线图！&quot;); &#125; return chart; &#125;&#125;// 客户端class Client &#123; public static void main(String args[]) &#123; Chart chart; chart = ChartFactory.getChart(&quot;histogram&quot;); //通过静态工厂方法创建产品 chart.display(); &#125;&#125; 实例改进引入 config.xml ，在配置文件中定义 chartType 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;chartType&gt;histogram&lt;/chartType&gt;&lt;/config&gt; 123456789101112131415161718192021222324252627282930313233343536import javax.xml.parsers.*;import org.w3c.dom.*;import org.xml.sax.SAXException;import java.io.*; public class XMLUtil &#123; //该方法用于从XML配置文件中提取图表类型，并返回类型名 public static String getChartType() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;config.xml&quot;)); //获取包含图表类型的文本节点 NodeList nl = doc.getElementsByTagName(&quot;chartType&quot;); Node classNode = nl.item(0).getFirstChild(); String chartType = classNode.getNodeValue().trim(); return chartType; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;class Client &#123; public static void main(String args[]) &#123; Chart chart; String type = XMLUtil.getChartType(); //读取配置文件中的参数 chart = ChartFactory.getChart(type); //创建产品对象 chart.display(); &#125;&#125; 优点 实现了对象创建和使用的分离，客户端只消费产品，不需要创建 客户端不需要知道创建产品类的类名，只需知道产品类对应的参数 通过引入配置文件，可以在不修改客户端的情况下更换或增加新的具体产品类 缺点 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统受影响 会增加系统中类的个数 扩展困难，一旦添加新产品就要修改工厂逻辑，可能造成工厂逻辑过于复杂 使用了静态工厂方法，工厂类无法形成基于继承的等级结构 适用场景 工厂类负责创建的对象较少 客户端只知道传入工厂类的参数，对如何创建对象不关心 工厂模式（Factory）创建对象时不会对客户端暴露创建逻辑，并且通过使用一个共同的接口来指向新创建的对象。 意图定义一个创建对象的接口，让子类自己决定实例化哪一个工厂类，使创建过程延迟到子类进行。 使用场景明确的计划不同条件创建不同实例 实现 抽象工厂模式（Abstract Factory）实现 单例模式（Singleton）意图保证一个类仅有一个实例，并提供一个访问它的全局访问点。 解决问题一个全局使用的类频繁创建与销毁。 优点 内存里只有一个实例，减少了内存开销 避免对资源的多重占用（比如写文件操作） 缺点没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 实现 实现方式懒汉式，线程不安全（不建议） 是否 Lazy 初始化：是 是否多线程安全：否 实现难度：易 懒汉式，线程安全（不建议） 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 饿汉式（建议）基于 classloader 机制避免了多线程的同步问题， 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 优点： 没有加锁，执行效率会提高 缺点： 类加载时就初始化，浪费内存，容易产生垃圾 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 双重校验锁（特殊需求使用） 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 优点： 安全且多线程时高效 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 静态内部类（明确需要 lazy loading 时使用）利用 classloader 机制来保证初始化 instance 时只有一个线程，与 饿汉式不同的是： 饿汉式只要类被加载，就会是实例化， 这种方式类被加载，不一定被实例化，只有通过显式调用 getInstance，才会装载 SingletonHolder，从而实例化 instance。 适用于静态域情况，双重校验方式可在实例域需要延迟初始化时使用 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 枚举（涉及反序列化创建对象使用） 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 建造者模式（Builder）原型模式（Prototype）结构型模式关注类和对象的组合用于描述如何将类或对象按某种布局组成更大的结构继承的概念被用来组合接口和定义组合对象获得新功能的方法。 适配器模式（Adapter）桥接模式（Bridge）意图将抽象部分与实现部分分离，使两者可以独立变化 解决问题有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展不灵活 缺点增加系统理解与设计难度 类图 过滤器模式（Filter、Criteria Pattern）允许使用不同标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。结合多个标准来获得单一标准。 类图 组合模式（Composite）装饰器模式（Decorator）外观模式（Facade）享元模式（Flyweight）代理模式（Proxy）行为型模式关注对象间的通信用于描述类或对象间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。 责任链模式（Chain of Responsibility）类图 命令模式（Command）解释器模式（Interpreter）迭代子模式（Iterator）中介者模式（Mediator）备忘录模式（Memento）观察者模式（Observer）状态模式（State）解决系统中复杂对象的状态转换以及不同状态下行为的封装问题 将一个对象的状态从对象中分离出来，封装到专门的状态类中对于客户端而言，无需关心对象状态的转换及对象所处的当前状态 定义允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 结构图 Context（上下文）： 拥有多种状态的对象，维护一个抽象状态类 State 的引用，通过 setState() 方法可以注入不同的状态对象。State（抽象状态类）： 定义一个接口以封装与上下文的一个特定状态相关的行为，声明了各种不同状态对应的方法，子类中需要实现这些方法，相同的方法可以在抽象状态类中实现。ConcreteState（具体状态类）： 抽象状态类的子类，每个子类实现一种状态的相应行为。 实例 1（使用具体状态类实现状态转换） Account充当环境类角色， AccountState充当抽象状态角色， NormalState、OverdraftState和RestrictedState充当具体状态角色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//银行账户：环境类class Account &#123; private AccountState state; //维持一个对抽象状态对象的引用 private String owner; //开户名 private double balance = 0; //账户余额 public Account(String owner,double init) &#123; this.owner = owner; this.balance = balance; this.state = new NormalState(this); //设置初始状态 System.out.println(this.owner + &quot;开户，初始金额为&quot; + init); System.out.println(&quot;---------------------------------------------&quot;); &#125; public void deposit(double amount) &#123; System.out.println(this.owner + &quot;存款&quot; + amount); state.deposit(amount); //调用状态对象的deposit()方法 System.out.println(&quot;现在余额为&quot;+ this.balance); System.out.println(&quot;现在帐户状态为&quot;+ this.state.getClass().getName()); System.out.println(&quot;---------------------------------------------&quot;); &#125; public void withdraw(double amount) &#123; System.out.println(this.owner + &quot;取款&quot; + amount); state.withdraw(amount); //调用状态对象的withdraw()方法 System.out.println(&quot;现在余额为&quot;+ this.balance); System.out.println(&quot;现在帐户状态为&quot;+ this. state.getClass().getName()); System.out.println(&quot;---------------------------------------------&quot;); &#125; public void computeInterest() &#123; state.computeInterest(); //调用状态对象的computeInterest()方法 &#125;&#125;//抽象状态类abstract class AccountState &#123; protected Account acc; public abstract void deposit(double amount); public abstract void withdraw(double amount); public abstract void computeInterest(); public abstract void stateCheck();&#125; //正常状态：具体状态类class NormalState extends AccountState &#123; public NormalState(Account acc) &#123; this.acc = acc; &#125; public NormalState(AccountState state) &#123; this.acc = state.acc; &#125; public void deposit(double amount) &#123; acc.setBalance(acc.getBalance() + amount); stateCheck(); &#125; public void withdraw(double amount) &#123; acc.setBalance(acc.getBalance() - amount); stateCheck(); &#125; public void computeInterest() &#123; System.out.println(&quot;正常状态，无须支付利息！&quot;); &#125; //状态转换 public void stateCheck() &#123; if (acc.getBalance() &gt; -2000 &amp;&amp; acc.getBalance() &lt;= 0) &#123; acc.setState(new OverdraftState(this)); &#125; else if (acc.getBalance() == -2000) &#123; acc.setState(new RestrictedState(this)); &#125; else if (acc.getBalance() &lt; -2000) &#123; System.out.println(&quot;操作受限！&quot;); &#125; &#125; &#125; //透支状态：具体状态类class OverdraftState extends AccountState&#123; public OverdraftState(AccountState state) &#123; this.acc = state.acc; &#125; public void deposit(double amount) &#123; acc.setBalance(acc.getBalance() + amount); stateCheck(); &#125; public void withdraw(double amount) &#123; acc.setBalance(acc.getBalance() - amount); stateCheck(); &#125; public void computeInterest() &#123; System.out.println(&quot;计算利息！&quot;); &#125; //状态转换 public void stateCheck() &#123; if (acc.getBalance() &gt; 0) &#123; acc.setState(new NormalState(this)); &#125; else if (acc.getBalance() == -2000) &#123; acc.setState(new RestrictedState(this)); &#125; else if (acc.getBalance() &lt; -2000) &#123; System.out.println(&quot;操作受限！&quot;); &#125; &#125;&#125; //受限状态：具体状态类class RestrictedState extends AccountState &#123; public RestrictedState(AccountState state) &#123; this.acc = state.acc; &#125; public void deposit(double amount) &#123; acc.setBalance(acc.getBalance() + amount); stateCheck(); &#125; public void withdraw(double amount) &#123; System.out.println(&quot;帐号受限，取款失败&quot;); &#125; public void computeInterest() &#123; System.out.println(&quot;计算利息！&quot;); &#125; //状态转换 public void stateCheck() &#123; if(acc.getBalance() &gt; 0) &#123; acc.setState(new NormalState(this)); &#125; else if(acc.getBalance() &gt; -2000) &#123; acc.setState(new OverdraftState(this)); &#125; &#125;&#125;// 客户端class Client &#123; public static void main(String args[]) &#123; Account acc = new Account(&quot;段誉&quot;,0.0); acc.deposit(1000); acc.withdraw(2000); acc.deposit(3000); acc.withdraw(4000); acc.withdraw(1000); acc.computeInterest(); &#125;&#125; 实现 2（使用环境类实现状态切换） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//屏幕类class Screen &#123; //枚举所有的状态，currentState表示当前状态 private State currentState, normalState, largerState, largestState; public Screen() &#123; this.normalState = new NormalState(); //创建正常状态对象 this.largerState = new LargerState(); //创建二倍放大状态对象 this.largestState = new LargestState(); //创建四倍放大状态对象 this.currentState = normalState; //设置初始状态 this.currentState.display(); &#125; public void setState(State state) &#123; this.currentState = state; &#125; //单击事件处理方法，封转了对状态类中业务方法的调用和状态的转换 public void onClick() &#123; if (this.currentState == normalState) &#123; this.setState(largerState); this.currentState.display(); &#125; else if (this.currentState == largerState) &#123; this.setState(largestState); this.currentState.display(); &#125; else if (this.currentState == largestState) &#123; this.setState(normalState); this.currentState.display(); &#125; &#125;&#125; //抽象状态类abstract class State &#123; public abstract void display();&#125; //正常状态类class NormalState extends State&#123; public void display() &#123; System.out.println(&quot;正常大小！&quot;); &#125;&#125; //二倍状态类class LargerState extends State&#123; public void display() &#123; System.out.println(&quot;二倍大小！&quot;); &#125;&#125; //四倍状态类class LargestState extends State&#123; public void display() &#123; System.out.println(&quot;四倍大小！&quot;); &#125;&#125; 12345678class Client &#123; public static void main(String args[]) &#123; Screen screen = new Screen(); screen.onClick(); screen.onClick(); screen.onClick(); &#125;&#125; 优点 封装了状态转换规则，对状态转换进行集中管理 将所有与某个状态的行为放到一个类中，只需注入一个不同状态对象就可实现不同行为 避免使用庞大的条件判断 可以共享一个状态对象，减少系统中对象个数 缺点 对开闭原则支持不好，增加状态需要修改状态转换代码，修改某个状态需要修改对应类。 使用不当会导致程序结构和代码混乱 适用场景 对象的行为依赖它的状态，状态的改变会导致行为的变化 包含大量对象状态有关的条件判断，增加或删除状态不方便，耦合性太高。 空对象模式（Null Object Pattern）策略模式（Strategy）将算法的定义和使用分离，一种可插入式(Pluggable)算法的实现方案灵活的选择解决途径，可以方便增加新的解决途径 定义定义一系列算法类，将每个算法封装起来，让他们可以相互替换，让算法独立于使用他的客户而变化。 每一个类封装一种具体算法，每一个类是一种策略，使用一个抽象策略来做规则定义。 结构图客户类 Context 中建立一个抽象策略类的引用，通过注入的方式在客户端传入一个具体策略对象，也可通过反射动态创建具体策略对象 实例 1MovieTicket充当环境类角色，Discount充当抽象策略角色，StudentDiscount、 ChildrenDiscount 和VIPDiscount充当具体策略角色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//电影票类：环境类class MovieTicket &#123; private double price; private Discount discount; //维持一个对抽象折扣类的引用 public void setPrice(double price) &#123; this.price = price; &#125; //注入一个折扣类对象 public void setDiscount(Discount discount) &#123; this.discount = discount; &#125; public double getPrice() &#123; //调用折扣类的折扣价计算方法 return discount.calculate(this.price); &#125;&#125; //折扣类：抽象策略类interface Discount &#123; public double calculate(double price);&#125; //学生票折扣类：具体策略类class StudentDiscount implements Discount &#123; public double calculate(double price) &#123; System.out.println(&quot;学生票：&quot;); return price * 0.8; &#125;&#125; //儿童票折扣类：具体策略类class ChildrenDiscount implements Discount &#123; public double calculate(double price) &#123; System.out.println(&quot;儿童票：&quot;); return price - 10; &#125;&#125; //VIP会员票折扣类：具体策略类class VIPDiscount implements Discount &#123; public double calculate(double price) &#123; System.out.println(&quot;VIP票：&quot;); System.out.println(&quot;增加积分！&quot;); return price * 0.5; &#125;&#125; 123456789101112131415161718192021222324252627282930import javax.xml.parsers.*;import org.w3c.dom.*;import org.xml.sax.SAXException;import java.io.*;class XMLUtil &#123;//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() &#123; try &#123; //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;config.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; &#125; catch(Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;config&gt; &lt;className&gt;StudentDiscount&lt;/className&gt;&lt;/config&gt; 123456789101112131415161718class Client &#123; public static void main(String args[]) &#123; MovieTicket mt = new MovieTicket(); double originalPrice = 60.0; double currentPrice; mt.setPrice(originalPrice); System.out.println(&quot;原始价为：&quot; + originalPrice); System.out.println(&quot;---------------------------------&quot;); Discount discount; discount = (Discount)XMLUtil.getBean(); //读取配置文件并反射生成具体折扣对象 mt.setDiscount(discount); //注入折扣对象 currentPrice = mt.getPrice(); System.out.println(&quot;折后价为：&quot; + currentPrice); &#125;&#125; 实例 2Container类充当环境角色Context，LayoutManager作为所有布局类的公共父类扮演了抽象策略角色，它给出所有具体布局类所需的接口，具体策略类是LayoutManager的子类，也就是各种具体的布局类，它们封装了不同的布局方式。也可以设计并实现自己的布局类，只需要将自己设计的布局类作为LayoutManager的子类就可以 优点 完美支持开闭原则，可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为 提供一种可替换继承关系的方法， 避免使用继承时算法与算法本身混在一起，不符合单一职责原则 避免使用继承时无法实现算法或行为运行时动态切换。 避免多重条件选择语句 缺点 客户端需要知道所有策略类，并自定决定使用哪一个策略。 会产生很多具体策略类，任何细小变化都需要增加一个新的具体策略类 无法同时使用多个策略类 使用场景 需要动态在几种算法中选择一种，可以将这些算法封装到一个个具体算法类中，这些算法类都是一个抽象算法类的子类。客户端可以选择任何一个具体算法类，并只需要维持一个抽象算法类的实例。 一个对象有很多行为，可以把这些行为转移到相应的具体策略里，避免难以维护的多重条件选择语句。 不希望客户端知道复杂的、与算法相关的数据结构 模板方法模式（Template Method）一种基于继承的代码复用技术 定义定义一个操作中算法的框架，将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构，即可重定义该算法的某些特定步骤。 某个方法实现需要多个步骤，其中有些步骤固定，而有些步骤不固定，存在可变性。 模板方法： 调用基本方法同时定义基本方法执行次序的方法基本方法： 实现功能的每个步骤对应的方法 在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，具体子类的基本方法将覆盖父类中定义的基本方法，子类的钩子方法也将覆盖父类的钩子方法，从而可以通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制 结构图在抽象类中，模板方法 TemplateMethod() 定义了算法的框架，在模板方法中调用基本方法以实现完整的算法，每一个基本方法如 PrimitiveOperation1()、PrimitiveOperation2() 等均实现了算法的一部分，对于所有子类都相同的基本方法可在父类提供具体实现，例如 PrimitiveOperation1()，否则在父类声明为抽象方法或钩子方法，由不同的子类提供不同的实现，例如 PrimitiveOperation2() 和 PrimitiveOperation3()。 实现方法模板方法、固定步骤的基本方法放在父类不固定步骤的基本方法声明在父类，实现在单独的子类运行时选择一种具体子类 模板方法定义在抽象类中组合基本方法 基本方法实现各个步骤的方法，是模板方法的组成部分 抽象方法 由抽象类声明、具体子类实现 具体方法 由一个抽象类或具体类声明并实现，子类可以覆盖也可以直接继承 钩子方法 由一个抽象类或具体类声明并实现，父类给出一个默认空实现（或非空实现） 优点 符合单一职责和开闭原则，不同子类可以提供不同实现，方便更换和增加新的子类 子类实现时不会改变父类中的执行顺序 可以实现一种反向控制结构，子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行 缺点 需要为每个基本方法不同实现提供一个子类，如果父类可变的方法太多，会导致类的个数增加，使得系统庞大，设计更抽象，这种情况可以结合桥接模式进行设计。 适用场景 对一些复杂算法进行分割，一次性实现一个算法的不变部分，并将可变的行为留给子类来实现 将算法中固定不变部分设计为模板方法和父类具体方法， 将可以改变的细节有子类来实现 需要提取子类公共行为集中到公共父类避免代码重复 需要通过子类来决定父类算法中某个步骤是否执行，实现对父类反向控制 访问者模式（Visitor）为不同类型的元素提供多种访问操作方式，而且可以在不修改原有系统的情况下增加新的操作方式。 定义提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 结构图Vistor（抽象访问者）： 为每个具体元素类声明一个访问操作，具体访问者需要实现这些操作方法。ConcreteVisitor（具体访问者）：实现每个由访问者声明的操作，每个操作作用于访问对象结构中一种类型的元素。Element（抽象元素）：抽象类或接口，通常以一个抽象访问者为参数。ConcreteElement（具体元素）：在实现方法中调用访问者的访问方法完成对一个元素的操作ObjectStructure（对象结构）：元素的集合，存放元素对象，并提供遍历元素方法。可以结合组合模式实现或一个简单的集合对象。 实例 1 Department充当抽象访问者角色FADepartment表示财务部，HRDepartment表示人力资源部，它们充当具体访问者角色，Employee充当抽象元素角色EmployeeList充当对象结构，用于存储员工列表；FulltimeEmployee表示正式员工，ParttimeEmployee表示临时工，它们充当具体元素角色 全职员工 临时工 财务部 人力资源部 新的访问者…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//员工类：抽象元素类interface Employee&#123; public void accept(Department handler); //接受一个抽象访问者访问&#125; //全职员工类：具体元素类class FulltimeEmployee implements Employee&#123; private String name; private double weeklyWage; private int workTime; public FulltimeEmployee(String name,double weeklyWage,int workTime) &#123; this.name = name; this.weeklyWage = weeklyWage; this.workTime = workTime; &#125;&#125; //兼职员工类：具体元素类class ParttimeEmployee implements Employee&#123; private String name; private double hourWage; private int workTime; public ParttimeEmployee(String name,double hourWage,int workTime) &#123; this.name = name; this.hourWage = hourWage; this.workTime = workTime; &#125;&#125; //部门类：抽象访问者类abstract class Department&#123; //声明一组重载的访问方法，用于访问不同类型的具体元素 public abstract void visit(FulltimeEmployee employee); public abstract void visit(ParttimeEmployee employee); &#125; //财务部类：具体访问者类class FADepartment extends Department&#123; //实现财务部对全职员工的访问 public void visit(FulltimeEmployee employee) &#123; int workTime = employee.getWorkTime(); double weekWage = employee.getWeeklyWage(); if(workTime &gt; 40) &#123; weekWage = weekWage + (workTime - 40) * 100; &#125; else if(workTime &lt; 40) &#123; weekWage = weekWage - (40 - workTime) * 80; if(weekWage &lt; 0) &#123; weekWage = 0; &#125; &#125; System.out.println(&quot;正式员工&quot; + employee.getName() + &quot;实际工资为：&quot; + weekWage + &quot;元。&quot;); &#125; //实现财务部对兼职员工的访问 public void visit(ParttimeEmployee employee) &#123; int workTime = employee.getWorkTime(); double hourWage = employee.getHourWage(); System.out.println(&quot;临时工&quot; + employee.getName() + &quot;实际工资为：&quot; + workTime * hourWage + &quot;元。&quot;); &#125; &#125; //人力资源部类：具体访问者类class HRDepartment extends Department&#123; //实现人力资源部对全职员工的访问 public void visit(FulltimeEmployee employee) &#123; int workTime = employee.getWorkTime(); System.out.println(&quot;正式员工&quot; + employee.getName() + &quot;实际工作时间为：&quot; + workTime + &quot;小时。&quot;); if(workTime &gt; 40) &#123; System.out.println(&quot;正式员工&quot; + employee.getName() + &quot;加班时间为：&quot; + (workTime - 40) + &quot;小时。&quot;); &#125; else if(workTime &lt; 40) &#123; System.out.println(&quot;正式员工&quot; + employee.getName() + &quot;请假时间为：&quot; + (40 - workTime) + &quot;小时。&quot;); &#125; &#125; //实现人力资源部对兼职员工的访问 public void visit(ParttimeEmployee employee) &#123; int workTime = employee.getWorkTime(); System.out.println(&quot;临时工&quot; + employee.getName() + &quot;实际工作时间为：&quot; + workTime + &quot;小时。&quot;); &#125; &#125; //员工列表类：对象结构class EmployeeList&#123; //定义一个集合用于存储员工对象 private ArrayList&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); public void addEmployee(Employee employee) &#123; list.add(employee); &#125; //遍历访问员工集合中的每一个员工对象 public void accept(Department handler) &#123; for(Object obj : list) &#123; ((Employee)obj).accept(handler); &#125; &#125;&#125; 123456789101112131415161718192021222324class Client&#123; public static void main(String args[]) &#123; EmployeeList list = new EmployeeList(); Employee fte1,fte2,fte3,pte1,pte2; fte1 = new FulltimeEmployee(&quot;张无忌&quot;,3200.00,45); fte2 = new FulltimeEmployee(&quot;杨过&quot;,2000.00,40); fte3 = new FulltimeEmployee(&quot;段誉&quot;,2400.00,38); pte1 = new ParttimeEmployee(&quot;洪七公&quot;,80.00,20); pte2 = new ParttimeEmployee(&quot;郭靖&quot;,60.00,18); list.addEmployee(fte1); list.addEmployee(fte2); list.addEmployee(fte3); list.addEmployee(pte1); list.addEmployee(pte2); Department dep; dep = (Department)XMLUtil.getBean(); list.accept(dep); &#125;&#125; 优点 方便增加新的访问者，符合开闭原则 集中有关元素对象的访问行为到一个访问者对象中 缺点 增加新的元素类很困难，违背开闭原则，每增加一个新的元素都要在抽象访问者类中增加一个新的抽象方法，并在每一个具体访问者类中增加相应的具体操作 破坏封装，元素对象会暴露一些内部操作和状态 适用场景 一个对象机构包含多个类型的对象，需要对这些对象实施依赖具体类型的操作。针对每一种具体的类型提供一个访问操作，不同类型的对象可以有不同的访问操作。 需要对一个对象结构中的对象进行不同且不相关的操作，避免污染对象的类，增加新操作时不需要修改这些类。 对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://abcdoc-cn.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"MySQL 语句执行顺序","slug":"MySQL/MySQL 语句执行顺序","date":"2021-04-25T05:30:34.000Z","updated":"2021-06-07T02:33:59.102Z","comments":true,"path":"MySQL/MySQL 语句执行顺序/","link":"","permalink":"https://abcdoc-cn.github.io/MySQL/MySQL%20%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"MySQL 语句执行顺序MySQL的语句一共分为11步，如下图所标注的那样， 最先执行的总是 FROM 操作，最后执行的是 LIMIT 操作。 其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。 如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。 下面我们来具体分析一下查询处理的每一个阶段 顺序 名称 说明 1 FORM 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1 2 ON 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 3 JOIN 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 4 WHERE 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 5 GROUP BY 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5. 6 CUBE / ROLLUP 对表VT5进行cube或者rollup操作，产生表VT6. 7 HAVING 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 8 SELECT 执行select操作，选择指定的列，插入到虚拟表VT8中。 9 DISTINCT 对VT8中的记录进行去重。产生虚拟表VT9. 10 ORDER BY 将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10. 11 LIMIT 取出指定行的记录，产生虚拟表VT11, 并将结果返回。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/tags/MySQL/"}]},{"title":"查找算法","slug":"算法/查找算法","date":"2021-04-25T05:21:14.000Z","updated":"2021-06-07T02:08:31.986Z","comments":true,"path":"算法/查找算法/","link":"","permalink":"https://abcdoc-cn.github.io/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","excerpt":"","text":"[TOC] 查找算法二分查找算法","categories":[{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法","slug":"算法/排序算法","date":"2021-04-25T05:13:31.465Z","updated":"2021-04-25T05:41:43.047Z","comments":true,"path":"算法/排序算法/","link":"","permalink":"https://abcdoc-cn.github.io/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"[TOC] 冒泡排序 重复走访要排序的元素列，依次比较两个相邻的元素，如果顺序错误，将他们交换 时间复杂度： $O(n^2)$ 空间复杂度： 0(1) 选择排序 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余未排序的元素中寻找到最小（或最大）的元素，然后放到已排序的序列的末尾，以此类推，知道全部待排序的数据元素个数为零。 插入排序 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 希尔排序 把记录按下标的一定增量分组，对每组使用插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 归并排序 将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列间有序 算法步骤 申请空间，空间大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤 3 直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 快速排序 堆排序 利用数据结构堆所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总小于（或大于）它的父节点。 时间复杂度： O(nlogn)算法步骤 创建一个堆 H[0…n-1] 把堆首（最大值）和堆尾互换 把堆的尺寸缩小 1， 并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置 重复步骤 2， 直到堆的尺寸为 1 计数排序 一种非基于比较的排序算法 时间复杂度： O(n+k) 空间复杂度： O(n+k) 要求： 输入的数据必须是有确定的范围的整数 算法步骤 花 O(n) 的时间扫描一下整个序列 A，获取最小值 min 和最大值 max 开辟新的空间创建新的数组 B，长度为 (max - min + 1) 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数 桶排序 一种基于计数的排序算法（计数排序可参考上节的内容）， 原理将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序） 算法步骤 设置固定数量的空桶。 把数据放到对应的桶中。 对每个不为空的桶中数据进行排序。 拼接不为空的桶中数据，得到结果 基数排序 一种非比较型整数排序算法 原理将整数按位数切割成不同的数字，然后按每个位数分别比较 算法步骤 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的前补零 从最低位开始，依次进行依次排序 从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列","categories":[{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Jenkins 打包 Virtual Studio 2015 C++工程","slug":"VS2015/Jenkins 打包 Virtual Studio 2015 C++工程","date":"2021-04-25T05:03:26.971Z","updated":"2021-04-25T05:05:06.500Z","comments":true,"path":"VS2015/Jenkins 打包 Virtual Studio 2015 C++工程/","link":"","permalink":"https://abcdoc-cn.github.io/VS2015/Jenkins%20%E6%89%93%E5%8C%85%20Virtual%20Studio%202015%20C++%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"Jenkins 打包 Virtual Studio 2015 C++工程1. 添加 MSBuild 插件 2. 配置编译环境 3. 创建构建任务 4. 选择构建选项 5. 配置 GIT 目录 6. 配置构建参数参数： /t:Rebuild /p:Configuration=Release /p:VisualStudioVersion=14.0 /p:TargetFrameworkVersion=v5.01 7. 提取结果文件提取文件目录和类型： Release/.exe,Release/.dll","categories":[{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/categories/VS2015/"}],"tags":[{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/tags/VS2015/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://abcdoc-cn.github.io/tags/Jenkins/"}]},{"title":"Win7 用 VS2015 编译 SqlCipher","slug":"VS2015/Win7 用 VS2015 编译 SqlCipher","date":"2021-04-25T04:59:09.399Z","updated":"2021-04-25T05:02:11.640Z","comments":true,"path":"VS2015/Win7 用 VS2015 编译 SqlCipher/","link":"","permalink":"https://abcdoc-cn.github.io/VS2015/Win7%20%E7%94%A8%20VS2015%20%E7%BC%96%E8%AF%91%20SqlCipher/","excerpt":"","text":"[TOC] Win7 用 VS2015 编译 SqlCipher准备工作 Visual Studio 2015 ActiveState ActivePerl，编译 OpenSSL 使用 MinGW，编译 SqlCipher 使用 OpenSSL-1.0.2m，从官网下载 SqlCipher，从 github 获取 安装 VS2015 过程略。 安装 ActivePerl 过程略。 安装 MinGW网址: http://sourceforge.net/projects/mingw/files/ 下载 Download mingw-get-setup.exe 安装 MinGW 是一个多步骤的过程。首先下载并安装包管理器/安装程序，然后使用它来安装编译器和 msys 。 安装完安装程序后，运行它并在基本窗格下安装msys base，developer-tools，mingw32-base , gcc-g ++ 和 mingw32-tcl。 编译 OpenSSL（32位）1234567891011cd C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\binvcvars32.batperl Configure VC-WIN32 no-asm --prefix=&quot;C:\\openssl-1.0.2m\\win32-release&quot;ms\\do_nasmnmake -f ms\\nt.maknmake -f ms\\nt.mak testnmake -f ms\\nt.mak installnmake -f ms\\ntdll.maknmake -f ms\\ntdll.mak testnmake -f ms\\ntdll.mak installnmake -f ms\\ntdll.mak clean 目录 C:\\openssl-1.0.2m\\win32-release 下生成了两个库文件： 动态库文件 libeay32.dll（位于./bin目录下） 静态库文件 libeay32.lib （位于./lib目录下） 编译 SqlCipher 将上一步生成的两个库文件 libeay32.dll 、 libeay32.lib 复制到 C:\\SqlCipher 目录下 管理员权限运行 C:\\mingw\\msys\\1.0\\msys.bat 批处理文件，进入msys shell命令环境 利用命令切换到 SqlCipher 目录 ```bash cd /c/sqlcipher 12345 运行以下命令进行配置（注意这是一行），不能复制粘贴，只能手输入：5. ```bash ./configure --with-crypto-lib=none --disable-tcl CFLAGS=&quot;-DSQLITE_HAS_CODEC -DSQLCIPHER_CRYPTO_OPENSSL -I/C/openssl-1.0.2m/win32-release/include /C/sqlcipher/libeay32.dll -L/C/sqlcipher/ -static-libgcc&quot; LDFLAGS=&quot;-leay32&quot; 执行命令 ```bash make clean make sqlite3.cpp 生成可执行文件sqlcipher.exe make 生成库文件sqlite3.dll make dll 1234567891011121314151617181920212223 生成 sqlite3.dll 和 sqlite3.def - 打开 32 位 Visual Studio 命令提示符 - cd c:\\sqlcipher - lib /def:sqlite3.def### **测试 SqlCipher**（命令行）现在应该有一个功能齐全的 sqlcipher.exe 可执行文件和 dll 文件。打开一个正常的命令（cmd.exe）提示符，导航到sqlcipher构建目录：```bashsqlcipher.exe test.dbsqlite&gt;PRAGMA key = &#x27;password&#x27;;sqlite&gt;create table testtable (id int, name varchar(20));sqlite&gt;insert into testtable (id,name) values (0,&#x27;alice&#x27;), (1,&#x27;bob&#x27;), (2,&#x27;charlie&#x27;);sqlite&gt;select * from testtable0:alice1:bob2:charliesqlite&gt;.exit 现在我们有一个数据库，其中有一些值，让我们退出并尝试访问它没有密码。 1234sqlcipher.exe test.dbsqlite&gt;select * from testtableError: file is encrypted or not a databasesqlite&gt;.exit 再次输入密码。 1234567sqlcipher.exe test.dbsqlite&gt;PRAGMA key = &#x27;password&#x27;;sqlite&gt;select * from testtable0:alice1:bob2:charliesqlite&gt;.exit 如果看起来工作正常，现在可以在十六进制编辑器中打开文件test.db，并验证它没有可辨别的结构。 如果您想要进行一些对比验证，请在没有PRAGMA密钥语句的情况下对新的数据库文件重复上述实验。它将使未加密的数据库，您将能够轻松地看到清晰的结构和原始数据。 测试 SqlCipher（VS2015）创建一个名为 SQLCipherTest 的 win32 控制台应用程序（关闭预编译头文件） 复制五个文件：sqlite3.exp，sqlite3.lib，sqlite3.def，sqlite3.dll和sqlite3.h到您的visual studio项目的源目录。 回到Visual Studio并在解决方案资源管理器中添加一个现有的头文件并选择sqlite3.h 打开项目属性 - &gt;配置属性 - &gt;连接器 - &gt;输入 - &gt;其他依赖项，并添加sqlite3.lib 在你的主源文件中输入如下的c程序： 123456789101112131415161718192021222324252627282930313233#include &quot;stdafx.h&quot;#include &quot;sqlite3.h&quot;static int callback(void *NotUsed, int argc, char **argv, char **azColName) &#123; int i; for (i = 0; i &lt; argc; i++) &#123; //loop over results printf(&quot;%s = %s\\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;); &#125; printf(&quot;\\n&quot;); return 0;&#125;int main()&#123; sqlite3 *db; if (sqlite3_open(&quot;name_and_path_for_db&quot;, &amp;db) == SQLITE_OK) &#123; printf(&quot;DB file is open\\n&quot;); if (sqlite3_exec(db, (const char*)&quot;PRAGMA key =&#x27;password&#x27;&quot;, NULL, NULL, NULL) == SQLITE_OK)&#123; printf(&quot;Accepted Key\\n&quot;); &#125;; if (sqlite3_exec(db, (const char*)&quot;CREATE TABLE testtable (id int, name varchar(20));&quot;, NULL, NULL, NULL) == SQLITE_OK) &#123; printf(&quot;Created Table\\n&quot;); &#125;; if (sqlite3_exec(db, (const char*)&quot;INSERT INTO testtable (id,name) values (0,&#x27;alice&#x27;), (1,&#x27;bob&#x27;), (2,&#x27;charlie&#x27;);&quot;, NULL, NULL, NULL) == SQLITE_OK) &#123; printf(&quot;Gave it some data\\n&quot;); &#125;; if (sqlite3_exec(db, (const char*)&quot;SELECT * FROM testtable;&quot;, callback, NULL, NULL) == SQLITE_OK) &#123; printf(&quot;Sent Select\\n&quot;); &#125;; &#125; sqlite3_close(db); return 0;&#125; 在调试器中运行它，你会看到select state的输出。 注释掉 CREATE TABLE 和 INSERT INTO 两个 if 语句块并再次运行它，您应该再次看到 select 语句的输出。 将 password 改为不同的东西，你不应该看到 SELECT 的输出。","categories":[{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/categories/VS2015/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://abcdoc-cn.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/tags/VS2015/"},{"name":"SQLite","slug":"SQLite","permalink":"https://abcdoc-cn.github.io/tags/SQLite/"}]},{"title":"Win7 用 VS2015 编译 openssl-1.0.2m","slug":"VS2015/Win7 用 VS2015 编译 openssl-1.0.2m","date":"2021-04-25T04:58:17.177Z","updated":"2021-04-25T05:03:00.776Z","comments":true,"path":"VS2015/Win7 用 VS2015 编译 openssl-1.0.2m/","link":"","permalink":"https://abcdoc-cn.github.io/VS2015/Win7%20%E7%94%A8%20VS2015%20%E7%BC%96%E8%AF%91%20openssl-1.0.2m/","excerpt":"","text":"[TOC] Win7 用 VS2015 编译 openssl-1.0.2m准备工作1）下载安装编译必须的ActivePerl： http://www.activestate.com/activeperl/downloads 安装完成后需要执行 ppm install dmake 安装 nmake 2）下载最新的openssl源码： https://www.openssl.org/source/ 本文下载的是 openssl-1.0.2m 版本，然后解压至 C 盘根目录 设置VC编译环境以下所有操作都是在【VS2015开发人员命令提示】中进行的， 具体位置一般是【开始-&gt;所有程序-&gt;Visual Studio 2015-&gt; Visual Studio Tools】下； 【编译 32 位 openssl 】 12cd C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\binvcvars32.bat 【编译 64 位 openssl 】 12cd C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64vcvars64.bat 配置编译文件和类型如果只是想编译 OpenSSL，请看下面： 1）先进入 openssl-1.0.2m 目录 1cd C:\\openssl-1.0.2m 2）配置输出目录和编译类型【编译32位、64位；release、debug有区别】 1perl Configure [编译类型] no-asm --prefix=&quot;[输出目录]&quot; – [编译类型]可以选择以下： 参数 含义 debug-VC-WIN32 编译32位debug版本 debug-VC-WIN64A 编译64位debug版本 VC-WIN32 编译32位release版本 VC-WIN64A 编译64位release版本 – [输出目录]理论任何地方都可以 3）配置模式： - 【编译32位openssl】,一般都使用 no-asm 模式： 1ms\\do_nasm - 如果之前编译使用了no-asm参数，否则会在编译引用了该openssl库的工程中出现”error LNK2001和error LNK2019 无法解析的外部符号”这个错误。 - 【编译64位openssl】 1ms\\do_win64a.bat - 执行这一步之后，在ms目录下会生成 nt.mak 和 ntdll.mak 两个编译配置文件 - nt.mak 用于生成静态lib库 - ntdll.mak 用于生成动态dll库 注意： 如果不是想单独拿编译好的库出来用，而是需要交叉编译，比如接着编译libcurl，则可以使用如下命令全部一次性编译32位所有版本的库：ms\\32all.bat no-asm如果想要交叉编译libcurl，还是用 libcurl\\project\\build-openssl.bat 更好，但不保证可以成功。 编译【静态库、动态库有区别】- 【编译openssl静态链接库】 123nmake -f ms\\nt.maknmake -f ms\\nt.mak testnmake -f ms\\nt.mak install - 【编译openssl动态链接库】 123nmake -f ms\\ntdll.maknmake -f ms\\ntdll.mak testnmake -f ms\\ntdll.mak install - 执行test命令可以测试编译好的库，测试成功了就可以运行install命令，运行完之后才会在输出目录中找到输出的编译好的库和加入工程时必要的include文件。 注意事项1）设置编译类型的时候千万别忘记 no-asm 参数，关闭汇编模式，否则会出现类似如下错误： Assembling: tmp32\\sha1-586.asm tmp32\\sha1-586.asm(1427) : error A2070: invalid instruction operands tmp32\\sha1-586.asm(1571) : error A2070: invalid instruction operands NMAKE : fatal error U1077: ‘ml’ : return code ‘0x1’ Stop. 2）设置VC编译环境的时候，注意有32位和64位的区别。 -———————————————————————————————————— 编译实例openssl目录：c:\\openssl-1.0.2m\\ 编译 32 位 Release 版本的 lib 的例子: 12345678cd C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\binvcvars32.batperl Configure VC-WIN32 no-asm --prefix=&quot;C:\\openssl-1.0.2m\\win32-release-lib&quot;ms\\do_nasmnmake -f ms\\nt.maknmake -f ms\\nt.mak testnmake -f ms\\nt.mak install 编译 64 位 Release 版本的 dll 的例子： 123456789cd C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\binvcvars32.batperl Configure VC-WIN64A no-asm --prefix=&quot;c:\\openssl-1.0.2m\\win64-release-dll&quot;ms\\do_win64a.batnmake -f ms\\ntdll.maknmake -f ms\\ntdll.mak testnmake -f ms\\ntdll.mak installnmake -f ms\\ntdll.mak clean 至此，就可以将 c:\\openssl-1.0.2m\\win32-release-lib 目录复制到需要使用的地方就可以使用了。","categories":[{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/categories/VS2015/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://abcdoc-cn.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/tags/VS2015/"},{"name":"openssl","slug":"openssl","permalink":"https://abcdoc-cn.github.io/tags/openssl/"}]},{"title":"Linux 配置 NTP 时钟同步","slug":"CentOS/Linux 配置 NTP 时钟同步","date":"2021-04-25T04:57:27.444Z","updated":"2021-04-25T04:57:27.444Z","comments":true,"path":"CentOS/Linux 配置 NTP 时钟同步/","link":"","permalink":"https://abcdoc-cn.github.io/CentOS/Linux%20%E9%85%8D%E7%BD%AE%20NTP%20%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5/","excerpt":"","text":"Linux 配置 NTP 时钟同步一、 安装NTP 下载 tar 包： ntp-ntp-4.2.8.tar.gz 上传 tar 包到需要安装时钟同步的服务端及客户端机器上 进入上传文件目录解压文件 1tar -zxvf ntp-ntp-4.2.8.tar.gz 进入解压后的文件目录： 1cd ntp-ntp-4.2.8 编译安装包 1./configure --prefix=/usr/local/ntp &amp;&amp; make 安装 1make install 二、 服务端配置1. 修改配置文件1命令： vi /etc/ntp.conf 【写入以下内容】 123456789101112## 权限设置restrict default nomodify## 开放本机的访问restrict 127.0.0.1driftfile /etc/ntp/driftlogfile /var/log/ntp.log## 设置上级同步服务器server 127.127.1.1fudge 127.127.1.1 stratum 5 2. 启动ntp服务1/usr/local/ntp/bin/ntpd start 三、 客户端配置 安装NTP，步骤与服务端相同 修改配置文件 1vi /etc/ntp.conf 1server 【NTP服务端IP】 手动同步时间 1/usr/local/ntp/bin/ntpdate 【NTP服务端IP】 自动同步时间 ```bash crontab –e 123``` bash*/5 * * * * /usr/local/ntp/bin/ntpdate 【NTP服务端IP】 四、可能出现的问题 客户端手动同步时，报错： 1no server suitable for synchronization found 出现此问题有三种情况： 服务端启动后需要等5分钟左右，才能进行同步 服务端启动失败，可以使用 watch /usr/local/ntp/bin/ntpq –p 命令查看服务端运行情况 防火墙拦截，关闭防火墙， service iptables stop 服务端使用 /usr/local/ntp/bin/ntpq –p 命令查询时间同步信息时，提示： 1no association ID`s returned 需要检查服务端配置文件是否正确","categories":[{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/tags/Linux/"},{"name":"NTP","slug":"NTP","permalink":"https://abcdoc-cn.github.io/tags/NTP/"}]},{"title":"CentOS8 使用 yum 安装 MySQL8","slug":"CentOS/CentOS8 使用 yum 安装 MySQL8","date":"2021-04-25T04:56:25.477Z","updated":"2021-04-25T04:56:25.477Z","comments":true,"path":"CentOS/CentOS8 使用 yum 安装 MySQL8/","link":"","permalink":"https://abcdoc-cn.github.io/CentOS/CentOS8%20%E4%BD%BF%E7%94%A8%20yum%20%E5%AE%89%E8%A3%85%20MySQL8/","excerpt":"","text":"[TOC] CentOS8 使用 yum 安装 MySQL8 CentOS Linux release 8.1.1911 (Core) mysql80-community-release-el8-1.noarch.rpm 卸载之前的安装1234[root@localhost ~]# rpm -qa | grep -i mysql# 强力删除，对相关依赖的文件也进行强力删除[root@localhost ~]# rpm -e --nodeps 软件名 安装服务端（mysql-server）123[root@localhost ~]# wget https://repo.mysql.com//mysql80-community-release-el8-1.noarch.rpm[root@localhost ~]# rpm -ivh mysql80-community-release-el8-1.noarch.rpm 1[root@localhost ~]# yum install mysql-server 查看是否安装成功1234567[root@localhost ~]# ps -ef | grep mysql[root@localhost ~]# cat /etc/group | grep mysql[root@localhost ~]# cat /etc/password | grep mysql[root@localhost ~]# mysqladmin --version 设置开机启动1234567891011[root@localhost ~]# systemctl list-unit-files|grep mysqldmysqld.service disabledmysqld@.service disabled# 设置开机启动[root@localhost ~]# systemctl enable mysqld.serviceCreated symlink /etc/systemd/system/multi-user.target.wants/mysqld.service → /usr/lib/systemd/system/mysqld.service.[root@localhost ~]# systemctl list-unit-files|grep mysqldmysqld.service enabledmysqld@.service disabled 启动服务123456# 查看是否启动MySQL服务[root@localhost ~]# ps -ef|grep mysqlroot 4311 32702 0 21:07 pts/4 00:00:00 grep --color=auto mysql#启动服务[root@localhost ~]# systemctl start mysqld.service 停止、重启服务12345678# 停止服务[root@localhost ~]# systemctl stop mysqld# 重启服务[root@localhost ~]# systemctl restart mysqld# 查看服务[root@localhost ~]# systemctl status mysqld 安全设置12[root@localhost ~]# mysql_secure_installation 重置密码12345678# 选择 mysql 数据库mysql&gt; use mysql;# 清空旧密码mysql&gt; update user set authentication_string=&#x27;&#x27; where user=&#x27;root&#x27;;# 重置新密码mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;11111111&#x27;; 赋权远程客户端123456789# 创建账户mysql&gt; create user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;11111111&#x27;;# 赋予权限# with grant option 选项表示该用户可以将自己拥有的权限授权给别人mysql&gt; grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;# 赋权生效，将当前 user 和 privilige 表中的用户信息/权限设置提取到内存mysql&gt; flush privileges;","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/categories/CentOS/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/tags/CentOS/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://abcdoc-cn.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"CentOS7 安装 HAProxy","slug":"CentOS/CentOS7 安装 HAProxy","date":"2021-04-25T04:55:47.329Z","updated":"2021-04-25T04:55:47.329Z","comments":true,"path":"CentOS/CentOS7 安装 HAProxy/","link":"","permalink":"https://abcdoc-cn.github.io/CentOS/CentOS7%20%E5%AE%89%E8%A3%85%20HAProxy/","excerpt":"","text":"[TOC] CentOS7 安装 HAProxy CentOS 7 HAproxy-1.3.20 安装12wget http://haproxy.1wt.eu/download/1.3/src/haproxy-1.3.20.tar.gztar -zxvf haproxy-1.3.20.tar.gz 将haproxy安装到 /usr/local/haproxy 12cd haproxy-1.3.20make TARGET=linux26 PREFIX=/usr/local/haproxy 开始安装安装 1# make install PREFIX=/usr/local/haproxy 配置安装完毕后，进入安装目录配置文件， 默认情况下目录里是没有 .cfg 配置文件的，可以从安装文件目录中 examples 下的 haproxy.cfg 拷贝到 /usr/local/haproxy 下 12# cd /usr/local/haproxy# vi haproxy.cfg 根据实际需求，更改配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243global #全局设置 log 127.0.0.1 local0 #日志输出配置，所有日志都记录在本机，通过local0输出 #log loghost local0 info maxconn 4096 #最大连接数 chroot /usr/local/haproxy uid 99 #所属运行的用户uid gid 99 #所属运行的用户组 daemon #以后台形式运行haproxy nbproc 2 #启动2个haproxy实例 pidfile /usr/local/haproxy/haproxy.pid #将所有进程写入pid文件 #debug #quietdefaults #默认设置 #log global log 127.0.0.1 local3 #日志文件的输出定向 mode http #所处理的类别,默认采用http模式，可配置成tcp作4层消息转发 option httplog #日志类别,采用httplog option dontlognull option forwardfor #如果后端服务器需要获得客户端真实ip需要配置的参数，可以从Http Header中获得客户端ip option httpclose #每次请求完毕后主动关闭http通道,haproxy不支持keep-alive,只能模拟这种模式的实现 retries 3 #3次连接失败就认为服务器不可用，主要通过后面的check检查 option redispatch #当serverid对应的服务器挂掉后，强制定向到其他健康服务器 maxconn 2000 #最大连接数 stats uri /haproxy-admin #haproxy 监控页面的访问地址 contimeout 5000 #连接超时时间 clitimeout 50000 #客户端连接超时时间 srvtimeout 50000 #服务器端连接超时时间stats auth admin:admin #设置监控页面的用户和密码：adminstats hide-version #隐藏统计页面的HAproxy版本信息frontend http-in #前台 bind *:80 mode http option httplog log global default_backend htmpool #静态服务器池backend htmpool #后台 balance leastconn #负载均衡算法 option httpchk HEAD /index.htm HTTP/1.0 #健康检查 server web1 10.16.0.9:8085 cookie 1 weight 5 check inter 2000 rise 2 fall 3 server web2 10.16.0.10:8085 cookie 2 weight 3 check inter 2000 rise 2 fall 3 负载均衡配置说明 12345#cookie 1 表示serverid为1，#check inter 1500 是检测心跳频率#rise 2 是2次正确认为服务器可用，#fall 3 是3次失败认为服务器不可用，#weight 5 代表权重 增加日志支持1# vim /etc/syslog.conf 在最下边增加 12local3.* /var/log/haproxy.loglocal0.* /var/log/haproxy.log 1#vim /etc/sysconfig/syslog 修改： 1SYSLOGD_OPTIONS=&quot;-r -m 0&quot; 重启日志服务 service syslog restart 设置开机启动为了方便系统在开机时加载，还可以创建启动脚本： 1# vim /etc/rc.d/init.d/haproxy 【内容如下】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#! /bin/shset -ePATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/haproxy/sbinPROGDIR=/usr/local/haproxyPROGNAME=haproxyDAEMON=$PROGDIR/sbin/$PROGNAMECONFIG=$PROGDIR/$PROGNAME.confPIDFILE=$PROGDIR/$PROGNAME.pidDESC=&quot;HAProxy daemon&quot;SCRIPTNAME=/etc/init.d/$PROGNAME# Gracefully exit if the package has been removed.test -x $DAEMON || exit 0start()&#123; echo -n &quot;Starting $DESC: $PROGNAME&quot; $DAEMON -f $CONFIG echo &quot;.&quot;&#125;stop()&#123; echo -n &quot;Stopping $DESC: $PROGNAME&quot; haproxy_pid=cat $PIDFILE kill $haproxy_pid echo &quot;.&quot;&#125;restart()&#123; echo -n &quot;Restarting $DESC: $PROGNAME&quot; $DAEMON -f $CONFIG -p $PIDFILE -sf $(cat $PIDFILE) echo &quot;.&quot;&#125;case &quot;$1&quot; in start) start ;; stop) stop ;; restart) restart ;; *) echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart&#125;&quot; &gt;&amp;2 exit 1 ;;esacexit 0 保存后赐予可执行权限 1# chmod +x /etc/rc.d/init.d/haproxy 就可以使用 service haproxy start|stop|restart 来控***务的启动停止跟重启。 并通过以下命令加载到开机服务启动列表 1# chkconfig --add haproxy 启动服务启动服务： 1# /usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/haproxy.cfg 重启服务 (没有换行)： 1# /usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/haproxy.cfg -st `cat /usr/local/haproxy/logs/haproxy.pid` 停止服务： 1# killall haproxy 访问在浏览器中输入 haproxy 监控地址: http://10.16.0.246:1080/haproxy-admin 在浏览器输入 haproxy 设置的 对外访问地址 访问系统","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/tags/CentOS/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://abcdoc-cn.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"HAProxy","slug":"HAProxy","permalink":"https://abcdoc-cn.github.io/tags/HAProxy/"}]},{"title":"CentOS7 安装 Docker","slug":"CentOS/CentOS7 安装 Docker","date":"2021-04-25T04:54:36.007Z","updated":"2021-04-25T04:54:36.007Z","comments":true,"path":"CentOS/CentOS7 安装 Docker/","link":"","permalink":"https://abcdoc-cn.github.io/CentOS/CentOS7%20%E5%AE%89%E8%A3%85%20Docker/","excerpt":"","text":"CentOS7 安装 DockerDocker 支持以下的 CentOS 版本： CentOS 7 (64-bit) CentOS 6.5 (64-bit) 或更高的版本 前提条件目前，CentOS 仅发行版本中的内核支持 Docker。 Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。 Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。 使用 yum 安装 （CentOS 7） Docker 要求 CentOS 系统的内核版本高于 3.10 查看当前的内核版本1uname -r 安装 Docker从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。 Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。 本文介绍 Docker CE 的安装使用 移除旧的版本12345678910$ yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装一些必要的系统工具1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存1sudo yum makecache fast 安装 Docker-ce1sudo yum -y install docker-ce 启动 Docker 后台服务1sudo systemctl start docker 测试运行 hello-world1docker run hello-world 由于本地没有 hello-world 这个镜像，所以会下载一个hello-world的镜像，并在容器内运行","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/tags/CentOS/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://abcdoc-cn.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Docker","slug":"Docker","permalink":"https://abcdoc-cn.github.io/tags/Docker/"}]},{"title":"C10K 问题","slug":"计算机网络/C10K 问题","date":"2021-04-25T04:53:16.000Z","updated":"2021-06-07T02:34:50.305Z","comments":true,"path":"计算机网络/C10K 问题/","link":"","permalink":"https://abcdoc-cn.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C10K%20%E9%97%AE%E9%A2%98/","excerpt":"","text":"C10K 问题问题由来 如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题 最初的服务器是 基于进程/线程模型 新到来一个TCP连接，就需要分配一个进程 假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的 问题的本质 本质上是操作系统的问题 对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是 requests per second 当创建的进程或线程多了 数据拷贝频繁（缓存I/O）、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大 导致操作系统崩溃 解决问题的关键 尽可能减少这些CPU资源消耗 解决方案从网络编程技术的角度来说，主要思路： 每个连接分配一个独立的线程/进程 同一个线程/进程同时处理多个连接 每个进程/线程处理一个连接 申请进程/线程是需要系统资源的 且系统需要管理这些进程/线程 会使资源占用过多 可扩展性差 每个进程/线程同时处理 多个连接(I/O多路复用)select 方式 使用 fd_set 结构体告诉内核同时监控那些文件句柄 使用逐个排查方式去检查是否有文件句柄就绪或者超时 缺点 文件句柄数量是有上线的 逐个检查吞吐量低 每次调用都要重复初始化 fd_set poll 方式 解决了 select 方式的2个缺点 链表方式存储 不同字段标注关注事件和发生事件 缺点 逐个去检查文件句柄是否就绪的问题仍然没有解决 epoll 方式（Linux） 使用”事件”的就绪通知方式， 通过 epoll_ctl 注册文件描述符 fd， 一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd, epoll_wait 便可以收到通知, 并通知应用程序 使用一个文件描述符管理多个描述符,将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间 通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高 不去轮询监听所有文件句柄是否已经就绪 只对发生变化的文件句柄感兴趣 异步 I/O 以及 Windows 该方式在windows上支持很好","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"VS2015 使用批处理方法打包 exe","slug":"VS2015/VS2015 使用批处理方法打包 exe","date":"2021-04-25T04:52:10.105Z","updated":"2021-04-25T04:52:10.105Z","comments":true,"path":"VS2015/VS2015 使用批处理方法打包 exe/","link":"","permalink":"https://abcdoc-cn.github.io/VS2015/VS2015%20%E4%BD%BF%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%89%93%E5%8C%85%20exe/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@echo offcd /d %~dp0setlocal enabledelayedexpansionfor /f &quot;delims=&quot; %%i in (&#x27;type &quot;config.ini&quot;^| find /i &quot;=&quot;&#x27;) do set %%irem Release / Debugset BUILD_CONFIG=Releaserem build / rebuild / cleanset BUILD_TYPE=clean;buildrem Any CPU / x64 / Win32set BUILD_PLATFORM=&quot;Win32&quot;@echo -------------------------@echo 编译开始@echo -------------------------cd /d %CPP_PATH%if not exist build md build@echo @echo 开始更新代码git pull origin master@echo @echo 生成 vs2015 工程到 build 目录cd /d %OUTPUT_PATH%cmake -T v140_xp ..@echo @echo 编译 可执行文件&quot;%MSBUILD_PATH%&quot; %SOLUTION_FILE% /t:%BUILD_TYPE% /p:Configuration=%BUILD_CONFIG%;Platform=%BUILD_PLATFORM%;OutDir=%OUTPUT_PATH%\\%BUILD_CONFIG% /m@echo 打包 安装文件cd /d %NSIS_PATH%makensisw &quot;%NSIS_FILE%&quot;cd /d %~dp0if not exist output-win md output-wincd /d %~dp0/output-winif not exist exe md exeif not exist pdb md pdbif not exist app md appcopy %OUTPUT_PATH%\\Release\\*.exe exe\\copy %OUTPUT_PATH%\\Release\\*.dll exe\\copy %OUTPUT_PATH%\\Release\\*.pdb pdb\\copy %OUTPUT_PATH%\\..\\install-script\\*-Setup*.exe@echo -------------------------@echo 编译结束@echo -------------------------pauseexit 0","categories":[{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/categories/VS2015/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"批处理","slug":"批处理","permalink":"https://abcdoc-cn.github.io/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/tags/VS2015/"}]},{"title":"Oracle 常用 SQL","slug":"Oracle/Oracle 常用 SQL","date":"2021-04-25T04:49:42.000Z","updated":"2021-06-07T02:55:30.786Z","comments":true,"path":"Oracle/Oracle 常用 SQL/","link":"","permalink":"https://abcdoc-cn.github.io/Oracle/Oracle%20%E5%B8%B8%E7%94%A8%20SQL/","excerpt":"","text":"使用正则表达式查询12345678910111213141516CREATE TABLE TABLEA(ID NUMBER(2) PRIMARY KEY,NUM NUMBER(10))CREATE SEQUENCE TABLE_SEQ;INSERT INTO TABLEA VALUES (TABLE_SEQ.NEXTVAL,111);INSERT INTO TABLEA VALUES (TABLE_SEQ.NEXTVAL,222);INSERT INTO TABLEA VALUES (TABLE_SEQ.NEXTVAL,333);INSERT INTO TABLEA VALUES (TABLE_SEQ.NEXTVAL,444);INSERT INTO TABLEA VALUES (TABLE_SEQ.NEXTVAL,555); with myview as(select &#x27;1,2,2,4,3&#x27; vchar from dual)select c.*from myview a , (select rownum as rn from dual connect by rownum &lt;=100) b ,tablea cwhere regexp_substr(VCHAR,&#x27;[^,]+&#x27;,1,rn) = c.idand regexp_substr(VCHAR,&#x27;[^,]+&#x27;,1,rn) is not null 权限管理 (DCL) 语句GRANT 权限常用的系统权限集合： CONNECT： 基本的连接 RESOURCE： 程序开发 DBA： 数据库管理 常用的数据对象权限： ALL ON 数据对象名 SELECT ON 数据对象名 UPDATE ON 数据对象名 DELETE ON 数据对象名 INSERT ON 数据对象名 ALTER ON 数据对象名 123GRANT CONNECT, RESOURCE TO 用户名;GRANT SELECT ON 表名 TO 用户名;GRANT SELECT, INSERT, DELETE ON 表名 TO 用户名1, 用户名2; REVOKE 回收权限123REVOKE CONNECT, RESOURCE FROM 用户名;REVOKE SELECT ON 表名 FROM 用户名;REVOKE SELECT, INSERT, DELETE ON表名 FROM 用户名1, 用户名2; 查看某对象的锁1234567891011121314151617181920SELECT A.OWNER, A.OBJECT_NAME, B.XIDUSN, B.XIDSLOT, B.XIDSQN, B.SESSION_ID, B.ORACLE_USERNAME, B.OS_USER_NAME, B.PROCESS, B.LOCKED_MODE, C.MACHINE, C.STATUS, C.SERVER, C.SID, C.SERIAL#, C.PROGRAMFROM ALL_OBJECTS A, V$LOCKED_OBJECT B, SYS.GV_$SESSION CWHERE (A.OBJECT_ID = B.OBJECT_ID) AND (B.PROCESS = C.PROCESS) AND A.OBJECT_NAME = upper(&#x27;&amp;table_name&#x27;); 中文字符按拼音排序1234567SELECT *FROM (SELECT &#x27;张三&#x27; NAME FROM DUAL UNION ALL SELECT &#x27;李四&#x27; NAME FROM DUAL UNION ALL SELECT &#x27;王五&#x27; NAME FROM DUAL)ORDER BY NLSSORT(NAME, &#x27;NLS_SORT=SCHINESE_PINYIN_M&#x27;); 第一个参数是需要排序的字段 第二个参数值可选下列字符串 SCHINESE_RADICAL_M 按照部首（第一顺序）、笔划（第二顺序）排序 SCHINESE_STROKE_M 按照笔划（第一顺序）、部首（第二顺序）排序 SCHINESE_PINYIN_M 按照拼音排序，系统的默认排序方式为拼音排序","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/categories/Oracle/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/tags/Oracle/"}]},{"title":"MySQL 异常处理","slug":"MySQL/MySQL 异常处理","date":"2021-04-25T04:45:15.000Z","updated":"2021-06-07T02:35:19.221Z","comments":true,"path":"MySQL/MySQL 异常处理/","link":"","permalink":"https://abcdoc-cn.github.io/MySQL/MySQL%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"[TOC] Access denied for user ‘root‘@’192.168.1.100’ (using password: YES)解决方法1grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27;; Packet for query is too large报错信息Caused by: com.mysql.jdbc.PacketTooBigException: Packet for query is too large (1354 &gt; 1024). You can change this value on the server by setting the max_allowed_packet’ variable 原因分析MySQL 根据配置文件会限制 Server 接受的数据包大小。有时候插入、更新或查询时数据包的大小，会受 max_allowed_packet 参数限制，导致操作失败。 查看 max_allowed_packet 参数： 在客户端执行： 1show VARIABLES like &#x27;%max_allowed_packet%&#x27;; 得到结果如下： Variable_name Value max_allowed_packet 1024 注意： 如果重复一直重复出现此问题，有可能是服务器内存容量不够或是黑客攻击，需要检查服务器及网络安全 解决方法方法一12345# 使用 root 用户登录 MySQLmysql -uroot -p# 修改配置set global max_allowed_packet = 100 * 1024 * 1024; 注意：此方法，MySQL重启后会失效 方法二修改 MySQL 配置文件 1234vim my.cnf# 在 [mysqId] 下面添加max_allowed_packet = 100M 重启 MySQL 如果找不到 my.cnf 可以通过一下命令查找 1mysql --help | grep my.cnf","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/categories/MySQL/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/tags/MySQL/"},{"name":"异常处理","slug":"异常处理","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"Linux 常用命令","slug":"Linux/Linux 常用命令","date":"2021-04-25T04:42:42.641Z","updated":"2021-04-25T04:43:09.637Z","comments":true,"path":"Linux/Linux 常用命令/","link":"","permalink":"https://abcdoc-cn.github.io/Linux/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"[TOC] 操作系统查看系统版本1234567891011121314151617181920# 查看当前操作系统版本信息[root@localhost ~]# cat /proc/versionLinux version 4.18.0-147.5.1.el8_1.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Wed Feb 5 02:00:39 UTC 2020# 查看当前操作系统内核信息[root@localhost ~]# uname -aLinux iZ2zeb33po2qdlf0ibaldcZ 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux# 查看当前操作系统发行信息[root@localhost ~]# cat /etc/centos-releaseCentOS Linux release 8.1.1911 (Core)# 查看系统版本信息，需要安装 yum install redhat-lsb -y[root@localhost etc]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 8.1.1911 (Core)Release: 8.1.1911Codename: Core 查看 CPU 信息1cat /etc/cpuinfo 网络ss 命令 socket statistic 的缩写 统计 Linux 系统中 socket 连接相关的信息 可以显示更多关于 TCP和状态相关的信息 和 netstat 相比，ss 命令在跟踪 TCP 连接和套接字方面速度更快，功能更强大 选项 参数 说明 -a 所有状态的套接字 -l 所有处于侦听状态（LISTEN）的套接字 -ua Unix 套接字 -wa Raw 套接字 -6a 所有 IPV6 套接字 -4a 所有 IPV4 套接字 -t 所有 TCP 套接字 -u 所有 UDP 套接字 -p 显示 进程名 -n 不解析服务名字，显示端口号 输出列 Netid socket 类型 State 套接字处于什么状态 三次握手四次挥手的状态 Recv-Q 在 ESTAB 状态下，表示内核中还有多少字节的数据没有被上层应用读取 如果这里数值很大，应用程序可能发生了阻塞 Send-Q 在 ESTAB 状态下，表示内核发送队列中还有多少字节的数据没有收到确认的ACK 如果这个数值很大，表明接收端的接收以及处理需要加强 Local Address:Port 本地地址和端口 Peer Address:Port 远程地址和端口 统计 Socket 连接数量1ss -a | wc -l 通过端口筛选1ss -ap sport eq 3306 通过进程名筛选1ss -an sport eq mysql 通过IP地址筛选通过目标地址筛选 1ss -a dst 27.38.240.99 通过源地址筛选 1ss -a src 192.168.0.9 netstat 命令CPU查看 CPU 的型号123cat /proc/cpuinfo | grep &#x27;model name&#x27; | sort | uniqmodel name : Intel(R) Xeon(R) CPU E5-2630 v4 @ 2.20GHz 查看 CPU 颗数插槽上的 CPU 个数, 物理 CPU 数量，可以数不重复的 physical id 个数 1cat /proc/cpuinfo | grep &#x27;physical id&#x27; | sort | uniq | wc -l 查看 CPU 核数一颗 CPU 上面能处理数据的芯片组的数量 1cat /proc/cpuinfo |grep &quot;cores&quot;|uniq|awk &#x27;&#123;print $4&#125;&#x27; 逻辑 CPU 核数一般情况，我们认为一颗cpu可以有多核，加上intel的超线程技术(HT), 可以在逻辑上把一个物理线程模拟出两个线程来使用，使得单个核心用起来像两个核一样，以充分发挥CPU的性能 逻辑CPU数量=物理cpu数量 x cpu cores 这个规格值 x 2(如果支持并开启超线程) top命令查询出来的就是逻辑CPU的数量 1cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l 内存free 命令 展示内存使用情况 展示了系统中空闲和已经使用了的物理内存、交换内存以及内核的缓冲区和页面缓存 所有展示的信息都是从 /proc/meminfo 文件解析出来的 默认以 KB(kbytes) 为单位 选项 选项 描述 备注 -h 还有多少可用内存 可用内存是 availabe 或者 free + buff/cache -t 显示物理内存和交换内存的总和 -s 每隔N秒输出一次 -c 重复输出N次 -w buff 和 cache 分开显示 -b 以 Bytes 为单位输出 自动忽略小于对应单位的数值 -k 以 KB 为单位输出 -m 以 MB 为单位输出 -g 以 GB 为单位输出 输出列 列 描述 备注 total 总内存的大小 used 已经使用内存 计算方式是：used = total - free - buff/cache free 还没有使用的内存 shared 进程之间的共享内存 buff/cache 内核缓冲区和页面缓存 如果应用程序需要的话，可以随时回收这部分缓存通过 free -w 命令可以分别显示 buff 和 cache 占用的内存 available 可用内存的预估大小 可以把 free 和 buff/cache 加起来看做 available 的近似值free + buff/cache ≈ available 每隔 N 秒输出一次12## 直到按 Ctrl + Z 停止free -s 2 重复输出3次，输出每隔2秒1free -c 3 -s 2 用户查看活动用户1w 文件查看文件属性1234567891011# 查看文件属性stat filename# 查看文件修改时间ls -l filename# 查看文件状态改动时间ls -lc filename# 查看文件访问时间ls -lu filename mtime： 最后一次修改文件或目录的时间 modify time 修改 mtime 时，ctime 必须随着改变，因为文件大小是属性，会随着变 atime 不一定会变，可以不访问文件对其内容进行修改 ctime： 最后一次改变文件或目录属性的时间 change time atime： 最后一次访问文件或目录的时间 access time 常用命令wc 命令 Word Count 的缩写 统计单词数，单词之间是以一个或多个空格、制表符、换行符分隔开的 字母、数字、以及空格、制表符和换行符都计算在内 选项 选项 说明 备注 -l 行数 -c 字节数 与 ls -lh 输出的字节数相同 -m 字符数 一个汉字算两个字符 -L 所有行中字符数最多那一行的字符数 -w 统计单词数 以一个或多个空格、制表符、换行符作为分隔符只要连续的字符之间出现空格、制表符、换行符中任一个字符，都当做两个单词 统计终端输入 终端上输入 wc 命令并回车 输入需要统计的字符 输入完最后按回车键 按 Ctrl + D 会输出统计的结果 输出列: 2行、4个单词、12个字节 统计行数12[root@centos-7]# wc -l a.txt3 a.txt 输出列： 总行数、文件名 统计多个文件每个文件之间以空格隔开 1234[root@centos-7]# wc -w a.txt b.txt 6 a.txt 1 b.txt 7 total 统计目录中对象数12[root@centos-7]# ls | wc -l4 查看 Linux 启动时间1date -d &quot;$(awk -F. &#x27;&#123;print $1&#125;&#x27; /proc/uptime) second ago&quot; +&quot;%Y-%m-%d %H:%M:%S&quot; 查看 Linux 已运行时间1cat /proc/uptime|awk -F. &#x27;&#123;run_days=$1 / 86400;run_hour=($1 % 86400)/3600;run_minute=($1 % 3600)/60;run_second=$1 % 60;printf(&quot;系统已运行：%d天%d时%d分%d 秒\\n&quot;,run_days,run_hour,run_minute,run_second)&#125;&#x27; 查看 Linux 历史启动时间1last -n 20 一个网卡设置多个 IP 临时设置，关机失效 同网段的电脑可以 ping 通 12ifconfig eth0:1 10.0.82.200 netmask 255.255.255.0ifconfig eth0:1 192.168.0.100 netmask 255.255.255.0 设置永久 IP1cd /etc/sysconfig/network-scripts 创建新文件 vim ifcfg-eth0:0，添加以下内容，保存退出 12345678910111213141516# 虚拟网络接口，随意DEVICE=eth0:0# 系统启动时激活ONBOOT=yes# 使用静态 ip 地址BOOTPROTO=static# 该虚拟网络接口的ip别名，随意IPADDR=192.168.1.100# 子网掩码，对应ip别名NETMASK=255.255.255.0# 网关，对应ip别名GATEWAY=192.168.1.1# 网卡MAC地址，与 eth0 相同HWADDR=46:07:60:4f:92:e3# 是否给予非root用户设备管理权限USERCTL=yes 重启网卡 1service network restart 临时清除ip别名 1ifconfig eth0:0 down CentOS 关闭防火墙修改 /etc/sysconfig/selinux 文件1[root@localhost ~]# vi /etc/sysconfig/selinux 找到防火墙设置语句 SELINUX=disabled 或 SELINUX=enforcing， 如果是 disable 则不用修改直接输入：q!退出。 如果是 enforcing 则将光标移动至字母e上，按x键，将该单词删除，再按a键，进入Insert模式，输入disabled 编辑结束后，按esc键，输入 :wq，保存退出 重启系统，使修改生效1[root@localhost ~]# reboot 查看防火墙状态12345678910111213141516[root@database ~]# service iptables statusTable: filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination 如果发现仍然有 ACCEPT 和 REJECT 列表，则说明配置没有生效，解决办法，手动执行： 1234[root@database ~]# service iptables stopiptables: Flushing firewall rules: [ OK ]iptables: Setting chains to policy ACCEPT: filter [ OK ]iptables: Unloading modules: [ OK ]","categories":[{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/categories/Linux/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/tags/Linux/"}]},{"title":"Linux 忘记 root 密码","slug":"Linux/Linux 忘记 root 密码","date":"2021-04-25T04:41:57.000Z","updated":"2021-06-07T02:35:34.257Z","comments":true,"path":"Linux/Linux 忘记 root 密码/","link":"","permalink":"https://abcdoc-cn.github.io/Linux/Linux%20%E5%BF%98%E8%AE%B0%20root%20%E5%AF%86%E7%A0%81/","excerpt":"","text":"Linux 忘记 root 密码rd.break方法 启动的时候，在启动界面，相应启动项，内核名称上按 “e”； 进入后，找到 linux16 开头的地方，按 “end” 键到最后，输入 rd.break，按 ctrl+x 进入； 进. 后输入命令 mount，发现根为 /sysroot/，并且不能写，只有 ro=readonly 权限； mount -o remount,rw /sysroot/，重新挂载，之后 mount，发现有了 r,w 权限； chroot /sysroot/ 改变根； echo redhat|passwd –stdin root 修改 root 密码为 redhat，或者输入 passwd，交互修改； 还有就是先 cp 一份，然后修改 /etc/shadow 文件 touch /.autorelabel 这句是为了 selinux 生效 ctrl+d 退出 然后 reboot","categories":[{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/categories/Linux/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/tags/Linux/"},{"name":"异常处理","slug":"异常处理","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"JDK8 Stream 常用方法","slug":"Java/JDK8 Stream 常用方法","date":"2021-04-25T04:40:44.571Z","updated":"2021-05-17T02:16:11.657Z","comments":true,"path":"Java/JDK8 Stream 常用方法/","link":"","permalink":"https://abcdoc-cn.github.io/Java/JDK8%20Stream%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Stream首先创建一个对象 123456789101112131415161718192021222324public class Employee &#123; private int id; private String name; private int age; private double salary; private Status status; public enum Status &#123; FREE, BUSY, VOCATION; &#125; public Employee() &#123; &#125; public Employee(int id, String name, int age, double salary, Status status) &#123; this.id = id; this.name = name; this.age = age; this.salary = salary; this.status = status; &#125; //省略get，set等。。。&#125; 随便初始化一些数据 12345678List&lt;Employee&gt; empList = Arrays.asList( new Employee(101, &quot;张三&quot;, 18, 9999.99, Status.FREE), new Employee(102, &quot;李四&quot;, 59, 6666.66, Status.BUSY), new Employee(103, &quot;王五&quot;, 28, 3333.33, Status.VOCATION), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.BUSY), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(104, &quot;赵六&quot;, 8, 7777.77, Status.FREE), new Employee(105, &quot;田七&quot;, 38, 5555.55, Status.BUSY)); 中间操作根据条件筛选 filter12345678/*** 接收Lambda, 从流中排除某些元素。*/@Testvoid testFilter() &#123; empList.stream().filter((e) -&gt; &#123; return e.getSalary() &gt;= 5000; &#125;).forEach(System.out::println);&#125; 跳过流的前n个元素 skip1234567/*** 跳过元素，返回一个扔掉了前n个元素的流。*/@Testvoid testSkip() &#123; empList.stream().filter((e) -&gt; e.getSalary() &gt;= 5000).skip(2).forEach(System.out::println);&#125; 去除重复元素 distinct1234567/*** 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素*/@Testvoid testDistinct() &#123; empList.stream().distinct().forEach(System.out::println);&#125; 截取流的前n个元素 limit123456789/*** 截断流，使其元素不超过给定数量。*/@Testvoid testLimit() &#123; empList.stream().filter((e) -&gt; &#123; return e.getSalary() &gt;= 5000; &#125;).limit(3).forEach(System.out::println);&#125; 映射 map1234567891011121314/*** 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素*/@Testvoid testMap() &#123; empList.stream().map(e -&gt; e.getName()).forEach(System.out::println); empList.stream().map(e -&gt; &#123; empList.forEach(i -&gt; &#123; i.setName(i.getName() + &quot;111&quot;); &#125;); return e; &#125;).collect(Collectors.toList());&#125; 自然排序 sorted1234567/*** 产生一个新流，其中按自然顺序排序*/@Testvoid testSorted() &#123; empList.stream().map(Employee::getName).sorted().forEach(System.out::println);&#125; 自定义排序 sorted(Comparator comp)12345678910111213/*** 产生一个新流，其中按自然顺序排序*/@Testvoid testSortedComparator() &#123; empList.stream().sorted((x, y) -&gt; &#123; if (x.getAge() == y.getAge()) &#123; return x.getName().compareTo(y.getName()); &#125; else &#123; return Integer.compare(x.getAge(), y.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 最终操作是否匹配任一元素 anyMatch12345678/** * 检查是否至少匹配一个元素 */@Testvoid testAnyMatch() &#123; boolean b = empList.stream().anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(&quot;boolean is : &quot; + b);&#125; 是否匹配所有元素 allMatch12345678/** * 检查是否匹配所有元素 */@Testvoid testAllMatch() &#123; boolean b = empList.stream().allMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(&quot;boolean is : &quot; + b);&#125; 是否未匹配所有元素 noneMatch12345678/** * 检查是否没有匹配的元素 */@Testvoid testNoneMatch() &#123; boolean b = empList.stream().noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(&quot;boolean is : &quot; + b);&#125; 返回第一个元素 findFirst123456789101112/** * 返回第一个元素 */@Testvoid testFindFirst() &#123; Optional&lt;Employee&gt; op = empList.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); if (op.isPresent()) &#123; System.out.println(&quot;first employee name is : &quot; + op.get().getName().toString()); &#125;&#125; 返回流中任意元素 findAny123456789101112/** * 返回当前流中的任意元素 */@Testvoid testFindAny() &#123; Optional&lt;Employee&gt; op = empList.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findAny(); if (op.isPresent()) &#123; System.out.println(&quot;any employee name is : &quot; + op.get().getName().toString()); &#125;&#125; 返回流的总数 count12345678/** * 返回流中元素的总个数 */@Testvoid testCount() &#123; long count = empList.stream().filter((e) -&gt; e.getStatus().equals(Status.FREE)).count(); System.out.println(&quot;Count is : &quot; + count);&#125; 返回流中的最大值 max12345678/** * 返回流中最大值 */@Testvoid testMax() &#123; Optional&lt;Double&gt; op = empList.stream().map(Employee::getSalary).max(Double::compare); System.out.println(op.get());&#125; 返回流中的最小值 min12345678/** * 返回流中最小值 */@Testvoid testMin() &#123; Optional&lt;Employee&gt; op2 = empList.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op2.get());&#125; 归约 reduce归约是将集合中的所有元素经过指定运算，折叠成一个元素输出 123456789101112131415161718192021222324/** * 可以将流中元素反复结合起来，得到一个值。返回T */@Testvoid testReduce() &#123; Optional&lt;Double&gt; op = empList.stream().map(Employee::getSalary).reduce(Double::sum); System.out.println(op.get());&#125;/** * 可以将流中元素反复结合起来，得到一个值，返回Optional&lt; T&gt; */@Testvoid testReduce1() &#123; Optional&lt;Integer&gt; sum = empList.stream().map(Employee::getName).flatMap(Java8Stream::filterCharacter) .map((ch) -&gt; &#123; if (ch.equals(&#x27;六&#x27;)) return 1; else return 0; &#125;).reduce(Integer::sum); System.out.println(sum.get());&#125; 将元素收集到 list 里 Collectors.toList()12345678/** * 把流中的元素收集到list里。 */@Testvoid testCollectorsToList() &#123; List&lt;String&gt; list = empList.stream().map(Employee::getName).collect(Collectors.toList()); list.forEach(System.out::println);&#125; 将元素收集到 set 里 Collectors.toSet()12345678/** * 把流中的元素收集到set里。 */@Testvoid testCollectorsToSet() &#123; Set&lt;String&gt; list = empList.stream().map(Employee::getName).collect(Collectors.toSet()); list.forEach(System.out::println);&#125; 把流中的元素收集到新创建的集合里 Collectors.toCollection(HashSet::new)12345678/** * 把流中的元素收集到新创建的集合里。 */@Testvoid testCollectorsToCollection() &#123; HashSet&lt;String&gt; hs = empList.stream().map(Employee::getName).collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println);&#125; 根据比较器选择最大值 Collectors.maxBy()12345678/** * 根据比较器选择最大值。 */@Testvoid testCollectorsMaxBy() &#123; Optional&lt;Double&gt; max = empList.stream().map(Employee::getSalary).collect(Collectors.maxBy(Double::compare)); System.out.println(max.get());&#125; 根据比较器选择最小值 Collectors.minBy()12345678/** * 根据比较器选择最小值。 */@Testvoid testCollectorsMinBy() &#123; Optional&lt;Double&gt; max = empList.stream().map(Employee::getSalary).collect(Collectors.minBy(Double::compare)); System.out.println(max.get());&#125; 对流中元素的某个字段求和 Collectors.summingDouble()12345678/** * 对流中元素的整数属性求和。 */@Testvoid testCollectorsSummingDouble() &#123; Double sum = empList.stream().collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum);&#125; 对流中元素的某个字段求平均值 Collectors.averagingDouble()12345678/** * 计算流中元素Integer属性的平均值。 */@Testvoid testCollectorsAveragingDouble() &#123; Double avg = empList.stream().collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg);&#125; 分组 Collectors.groupingBy类似sql的 group by 123456789/** * 分组 */@Testvoid testCollectorsGroupingBy() &#123; Map&lt;Status, List&lt;Employee&gt;&gt; map = empList.stream().collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map);&#125; 多级分组12345678910111213141516/** * 多级分组 */@Testvoid testCollectorsGroupingBy1() &#123; Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = empList.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123; if (e.getAge() &gt;= 60) return &quot;老年&quot;; else if (e.getAge() &gt;= 35) return &quot;中年&quot;; else return &quot;成年&quot;; &#125;))); System.out.println(map);&#125; 字符串拼接 Collectors.joining()12345678/** * 字符串拼接 */@Testvoid testCollectorsJoining() &#123; String str = empList.stream().map(Employee::getName).collect(Collectors.joining(&quot;,&quot;, &quot;----&quot;, &quot;----&quot;)); System.out.println(str);&#125; 12345678public static Stream&lt;Character&gt; filterCharacter(String str) &#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/categories/Java/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/tags/Java/"}]},{"title":"C++ 标准模板库 STL","slug":"C++/C++ 标准模板库 STL","date":"2021-04-24T17:51:31.000Z","updated":"2021-06-10T08:50:46.000Z","comments":true,"path":"C++/C++ 标准模板库 STL/","link":"","permalink":"https://abcdoc-cn.github.io/C++/C++%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%20STL/","excerpt":"","text":"[TOC] STL（standard template library） 标准模板库 一套功能强大的 C++ 模板类， 提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 STL 组成结构（6个） 组件 描述 容器（Containers） 一些封装数据结构的模板类。容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 &lt;algorithm&gt; 中，少部分位于头文件 &lt;numeric&gt; 中 迭代器（Iterators） 容器和算法之间的胶合剂。对容器中数据的读和写，是通过迭代器完成的。迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 函数对象 如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 适配器 可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 内存分配器 为容器类模板提供自定义的内存申请和释放功能，往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 STL 头文件（13个） 按照 C++ 标准库的规定，所有标准头文件都不再有扩展名 &lt;iterator&gt;&lt;functional&gt;&lt;vector&gt;&lt;deque&gt;&lt;list&gt;&lt;queue&gt;&lt;stack&gt;&lt;set&gt;&lt;map&gt;&lt;algorithm&gt;&lt;numeric&gt;&lt;memory&gt;&lt;utility&gt; 复杂度 复杂度 元素个数 元素个数 元素个数 元素个数 元素个数 元素个数 元素个数 元素个数 种类 大 O 表示 1 2 5 10 50 100 1 000 10 000 常量阶 O(1) 1 1 1 1 1 1 1 1 对数阶 O(log(n)) 1 2 3 4 6 7 10 13 线性阶 O(n) 1 2 5 10 50 100 1 000 10 000 2次方 O(n2) 1 4 25 100 2500 10 000 1 000 000 100 000 000 STL 容器 一些模板类的集合，容器中封装的是组织数据的方法（也就是数据结构） 合理组织数据的存取与选择处理数据的算法同等重要 存取数据的方式往往会直接影响到对它们进行增删改查操作的复杂程度和时间消耗 容器种类 功能 序列容器 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。 排序容器 包括 set 集合容器、multiset 多重集合容器、map 映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 哈希容器 C++ 11新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 哈希容器直到 C++ 11 才被正式纳入 C++ 标准程序库 序列容器 array&lt;T,N&gt;（数组容器） 可以存储 N 个 T 类型的元素 一旦建立，其长度固定不变 不能增加或删除元素，只能改变某个元素的值 定义1234namespace std&#123; template &lt;typename T, size_t N&gt; class array;&#125; 初始化方式12345678910111213// 方式一（不推荐）// 由于未显式指定这 10 个元素的值，// 各个元素的值是不确定的（array 容器不会做默认初始化操作）std::array&lt;double, 10&gt; values;// 方式二// 所有的元素初始化为 0 或者和默认元素类型等效的值std::array&lt;double, 10&gt; values &#123;&#125;;// 方式三// 初始化了前 4 个元素，剩余的元素都会被初始化为 0.0std::array&lt;double, 10&gt; values &#123;0.5,1.0,1.5,2.0&#125;; vector（向量容器） 存放 T 类型的元素 长度可变，存储空间不足时，会自动申请更多的内存 在尾部增加或删除元素的效率最高 时间复杂度为 O(1) 常数阶 在其它位置插入或删除元素效率较差 时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数 deque（双端队列容器） 和 vector 非常相似 不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效 时间复杂度都是 O(1) 常数阶 在容器中某一位置处插入或删除元素效率较差 时间复杂度为 O(n) 线性阶 list（链表容器） 存放 T 类型的元素 长度可变，存储空间不足时，会自动申请更多的内存 以双向链表的形式组织元素 序列的任何地方都可以高效地增加或删除元素 时间复杂度都为常数阶 O(1) 访问容器中任意元素的速度要比前三种容器慢 因为 list 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素 forward_list（正向链表容器） 和 list 容器非常类似 以单链表的形式组织元素 只能从第一个元素开始访问 比链表容器快、更节省内存 迭代器 将容器和算法分开 遍历读写容器数据 隐藏容器内部差异，以统一的界面面向算法传送数据 5 种迭代器 输入迭代器 输出迭代器 前向迭代器（forward iterator） 支持 ++p，p++ 操作 支持 *p 操作 可以被复制 可以被赋值 可以用 == 和 != 运算符进行比较 两个正向迭代器可以互相赋值 双向迭代器（bidirectional iterator） 具有正向迭代器的全部功能 可以进行 –p 或者 p– 操作（即一次向后移动一个位置） 随机访问迭代器（random access iterator） 具有双向迭代器的全部功能 可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较 p2-p1： 返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一） p+=i：使得 p 往后移动 i 个元素。 p-=i：使得 p 往前移动 i 个元素。 p+i：返回 p 后面第 i 个元素的迭代器。 p-i：返回 p 前面第 i 个元素的迭代器。 p[i]：返回 p 后面第 i 个元素的引用。 不同容器的迭代器 容器 对应的迭代器类型 array 随机访问迭代器 vector 随机访问迭代器 deque 随机访问迭代器 list 双向迭代器 set / multiset 双向迭代器 map / multimap 双向迭代器 forward_list 前向迭代器 unordered_map / unordered_multimap 前向迭代器 unordered_set / unordered_multiset 前向迭代器 stack 不支持迭代器 queue 不支持迭代器 迭代器的 4 种定义方式 迭代器定义方式 具体格式 正向迭代器 容器类名::iterator 迭代器名; 常量正向迭代器 容器类名::const_iterator 迭代器名; 反向迭代器 容器类名::reverse_iterator 迭代器名; 常量反向迭代器 容器类名::const_reverse_iterator 迭代器名; *迭代器名就表示迭代器指向的元素 常量迭代器和非常量迭代器的分别在于： 通过非常量迭代器还能修改其指向的元素 反向迭代器和正向迭代器的区别在于： 对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素； 而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素 以上 4 种定义迭代器的方式，并不是每个容器都适用 示例12345678910111213141516171819202122232425262728293031323334353637383940//遍历 vector 容器。#include &lt;iostream&gt;//需要引入 vector 头文件#include &lt;vector&gt;using namespace std;int main() &#123; //v被初始化成有10个元素 vector&lt;int&gt; v&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; //像普通数组一样使用vector容器 cout &lt;&lt; &quot;第一种遍历方法：&quot; &lt;&lt; endl; for (int i = 0; i &lt; v.size(); ++i) &#123; cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; &#125; //创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式 cout &lt;&lt; endl &lt;&lt; &quot;第二种遍历方法：&quot; &lt;&lt; endl; vector&lt;int&gt;::iterator i; //用 != 比较两个迭代器 for (i = v.begin(); i != v.end(); ++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; //用 &lt; 比较两个迭代器 cout &lt;&lt; endl &lt;&lt; &quot;第三种遍历方法：&quot; &lt;&lt; endl; for (i = v.begin(); i &lt; v.end(); ++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl &lt;&lt; &quot;第四种遍历方法：&quot; &lt;&lt; endl; i = v.begin(); while (i &lt; v.end()) &#123; //间隔一个输出 cout &lt;&lt; *i &lt;&lt; &quot; &quot;; // 随机访问迭代器支持 &quot;+= 整数&quot; 的操作 i += 2; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://abcdoc-cn.github.io/tags/STL/"},{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"}],"author":"abcdoc"},{"title":"Cron 表达式","slug":"常用工具/Cron 表达式","date":"2021-04-23T05:28:26.028Z","updated":"2021-04-23T08:04:28.351Z","comments":true,"path":"常用工具/Cron 表达式/","link":"","permalink":"https://abcdoc-cn.github.io/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Cron%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"Cron表达式 Cron表达式是一个字符串，包括6~7个时间元素，在SpringTask中可以用于指定任务的执行时间。 Cron的语法格式Seconds Minutes Hours DayofMonth Month DayofWeek Cron格式中每个时间元素的说明 时间元素 可出现的字符 有效数值范围 Seconds , - * / 0-59 Minutes , - * / 0-59 Hours , - * / 0-23 DayofMonth , - * / ? L W 0-31 Month , - * / 1-12 DayofWeek , - * / ? L # 1-7或SUN-SAT Cron格式中特殊字符说明 字符 作用 举例 , 列出枚举值 在Minutes域使用5,10，表示在5分和10分各触发一次 - 表示触发范围 在Minutes域使用5-10，表示从5分到10分钟每分钟触发一次 * 匹配任意值 在Minutes域使用*, 表示每分钟都会触发一次 / 起始时间开始触发，每隔固定时间触发一次 在Minutes域使用5/10,表示5分时触发一次，每10分钟再触发一次 ? 在DayofMonth和DayofWeek中，用于匹配任意值 在DayofMonth域使用?,表示每天都触发一次 # 在DayofMonth中，确定第几个星期几 1#3表示第三个星期日 L 表示最后 在DayofWeek中使用5L,表示在最后一个星期四触发 W 表示有效工作日(周一到周五) 在DayofMonth使用5W，如果5日是星期六，则将在最近的工作日4日触发一次","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://abcdoc-cn.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"}],"tags":[]},{"title":"JDK keytool 用法","slug":"Java/JDK keytool 用法","date":"2021-04-23T05:27:36.310Z","updated":"2021-04-23T08:05:23.334Z","comments":true,"path":"Java/JDK keytool 用法/","link":"","permalink":"https://abcdoc-cn.github.io/Java/JDK%20keytool%20%E7%94%A8%E6%B3%95/","excerpt":"","text":"1keytool -import -alias &quot;tsinghua&quot; -keystore &quot;C:\\Program Files\\Java\\jdk1.8.0_77\\jre\\lib\\security\\cacerts&quot; -file C:\\Users\\zhanbo\\Desktop\\tsinghua.cer 1keytool -printcert -rfc -sslServer &quot;http://updates.jenkins-ci.org&quot;","categories":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/tags/Java/"}]},{"title":"Hexo 报错： ERROR Deployer not found git","slug":"Hexo/Hexo 报错：ERROR Deployer not found git","date":"2021-04-23T05:27:23.000Z","updated":"2021-06-15T08:15:19.632Z","comments":true,"path":"Hexo/Hexo 报错：ERROR Deployer not found git/","link":"","permalink":"https://abcdoc-cn.github.io/Hexo/Hexo%20%E6%8A%A5%E9%94%99%EF%BC%9AERROR%20Deployer%20not%20found%20git/","excerpt":"","text":"12$ hexo dERROR Deployer not found: git 1npm install --save hexo-deployer-git","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://abcdoc-cn.github.io/categories/Hexo/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"Hexo","slug":"Hexo","permalink":"https://abcdoc-cn.github.io/tags/Hexo/"}]},{"title":"SpringBoot 打包可执行 jar","slug":"SpringBoot/SpringBoot 打包可执行 jar","date":"2021-04-23T05:27:23.000Z","updated":"2021-06-07T02:35:58.980Z","comments":true,"path":"SpringBoot/SpringBoot 打包可执行 jar/","link":"","permalink":"https://abcdoc-cn.github.io/SpringBoot/SpringBoot%20%E6%89%93%E5%8C%85%E5%8F%AF%E6%89%A7%E8%A1%8C%20jar/","excerpt":"","text":"配置 pom.xml在 pom.xml 中添加 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;plugins&gt; &lt;!-- 将 前端 页面一同打包到 Jar 包中 --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-resources&lt;/id&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes/static&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;../web/dist&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 打包可执行的 jar 包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt; 打包部署在项目根目录下（即包含pom.xml的目录），在命令行里输入： 1mvn clean package 等待打包完成，出现 [INFO] BUILD SUCCESS 即为打包成功。 运行发布把 target 目录下的 *-exec.jar 包放到 服务器 目录下，直接执行命令： 1nohup java -jar *-exec.jar &gt; nohup.out &amp;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://abcdoc-cn.github.io/categories/SpringBoot/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://abcdoc-cn.github.io/tags/SpringBoot/"}]},{"title":"批处理命令","slug":"批处理命令/批处理命令","date":"2021-04-23T05:27:13.137Z","updated":"2021-04-23T07:38:46.485Z","comments":true,"path":"批处理命令/批处理命令/","link":"","permalink":"https://abcdoc-cn.github.io/%E6%89%B9%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/%E6%89%B9%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用命令复制包含关键字的行到新文件1findstr /c:&quot;keyworld&quot; old-file.txt &gt; new-file.txt 关闭回显 @ 的作用就是关闭紧跟其后的一条命令的回显 echo 显示 echo. 输出一个空行，相当于敲一个回车 “.” 必须紧跟在 echo 命令的后面，而且 “.” 也可以被 ，：；”／等任一的符号代替 12345rem 后面所有的命令均不显示，包括本条命令@echo offrem 后面所有的命令均不显示，但本条命令是显示的echo off pause 暂停执行12rem 请按任意键以继续pause 12rem 其他提示语echo 其他提示语 &amp; pause &gt; nul Set 设置变量123set a=1rem 显示 变量echo %a% Set 是否继续执行123456789101112:: 输入 y，执行操作:: 输入 n，跳过执行:: 输入 q，退出执行set /p input=&quot;是否继续执行 (y/n/q): &quot;if %input% == y ( rem 执行操作) else ( if %input% == q ( pause exit 0 )) title 改变窗口标题12:: 使用之后就会显示新的标题框了title 新标题 call 调用另一个批处理文件123call E:\\Temp.batrem 正在执行 Temp.batpause attrib 更改文件属性123:: 将文件夹Temp属性设为存档、系统、隐藏属性:: 如果没有在 Temp 所在路径执行需要加上Temp的路径attrib +a +s +h Temp 修改系统时间12echo 设置时间为23:59:10time 23:59:10 跳转当前目录1cd /d %~dp0 循环获取 config.ini 参数12345678910@echo offcd /d %~dp0setlocal enabledelayedexpansionfor /f &quot;delims=&quot; %%i in (&#x27;type &quot;config.ini&quot;^| find /i &quot;=&quot;&#x27;) do set %%i:: 使用方法echo %ZIP_PATH%echo %MSBUILD_PATH% config.ini 内容 12ZIP_PATH=&quot;C:\\Program Files\\WinRAR\\&quot;MSBUILD_PATH=C:\\Program Files (x86)\\MSBuild\\14.0\\Bin\\MSBuild.exe 目录操作mklink 创建目录链接12:: 创建 pathA 到 pathB 链接mklink /j pathB pathA md 创建目录12:: 如果 app 目录不存在，创建 app 目录if not exist app md app cp 拷贝文件12:: 将 uninst.exe 拷贝到 app 目录copy %SETUP_PATH%\\app\\uninst.exe app\\ WinRAR添加到压缩文件命令格式： RAR &lt;命令&gt; [ -&lt;开关&gt; ] &lt;压缩文件&gt; [ &lt;@列表文件…&gt; ] 1&quot;C:\\Program Files (x86)\\WinRAR\\WinRAR.exe&quot; a -as -r -ibck new.zip file1.ini path1 参数 说明 a 备份所有文件 -as 同步压缩文件内容 -r 备份目录和子目录 -ibck 后台运行","categories":[],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"批处理","slug":"批处理","permalink":"https://abcdoc-cn.github.io/tags/%E6%89%B9%E5%A4%84%E7%90%86/"}]},{"title":"pom.xml配置文件说明","slug":"Maven/pom.xml 配置文件说明","date":"2021-04-23T05:26:16.000Z","updated":"2021-06-07T02:36:20.529Z","comments":true,"path":"Maven/pom.xml 配置文件说明/","link":"","permalink":"https://abcdoc-cn.github.io/Maven/pom.xml%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/","excerpt":"","text":"pom.xml 配置文件说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符--&gt; &lt;artifactId/&gt; &lt;!--被继承的父项目的全球唯一标识符--&gt; &lt;groupId/&gt; &lt;!--被继承的父项目的版本--&gt; &lt;version/&gt; &lt;!--父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt; &lt;groupId&gt;xyz.devabc&lt;/groupId&gt; &lt;!--构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。--&gt; &lt;artifactId&gt;zhangboxyz-maven&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目的名称, Maven产生的文档用--&gt; &lt;name&gt;zhangboxyz-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://www.baidu.com/zhangboxyz&lt;/url&gt; &lt;!--项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。--&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt; &lt;maven/&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字，--&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL--&gt; &lt;url&gt;http://jira.baidu.com/zhangboxyz&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息--&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum--&gt; &lt;system/&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt; &lt;url/&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt; &lt;notifier&gt; &lt;!--传送通知的途径--&gt; &lt;type/&gt; &lt;!--发生错误时是否通知--&gt; &lt;sendOnError/&gt; &lt;!--构建失败时是否通知--&gt; &lt;sendOnFailure/&gt; &lt;!--构建成功时是否通知--&gt; &lt;sendOnSuccess/&gt; &lt;!--发生警告时是否通知--&gt; &lt;sendOnWarning/&gt; &lt;!--不赞成使用。通知发送到哪里--&gt; &lt;address/&gt; &lt;!--扩展配置项--&gt; &lt;configuration/&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt; &lt;inceptionYear/&gt; &lt;!--项目相关邮件列表信息--&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt; &lt;mailingList&gt; &lt;!--邮件的名称--&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;post&gt;zhangboxyz@163.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;subscribe&gt;zhangboxyz@163.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;unsubscribe&gt;zhangboxyz@163.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL--&gt; &lt;archive&gt;http:/hi.baidu.com/zhangboxyz&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表--&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息--&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符--&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名--&gt; &lt;name&gt;zhangboxyz&lt;/name&gt; &lt;!--项目开发者的email--&gt; &lt;email&gt;zhangboxyz@163.com&lt;/email&gt; &lt;!--项目开发者的主页的URL--&gt; &lt;url/&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织--&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL--&gt; &lt;organizationUrl&gt;http://hi.baidu.com/zhangboxyz&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等--&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表--&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素--&gt; &lt;contributor&gt; &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt; &lt;license&gt; &lt;!--license用于法律上的名称--&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL--&gt; &lt;url&gt;http://www.baidu.com/zhangboxyz/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息--&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/zhangboxyz/ &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/zhangboxyz &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt; &lt;tag/&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt; &lt;url&gt;http://svn.baidu.com/zhangboxyz&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt; &lt;organization&gt; &lt;!--组织的全名--&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL--&gt; &lt;url&gt;http://www.baidu.com/zhangboxyz&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;sourceDirectory/&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt; &lt;scriptSourceDirectory/&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;testSourceDirectory/&gt; &lt;!--被编译过的应用程序class文件存放的目录。--&gt; &lt;outputDirectory/&gt; &lt;!--被编译过的测试class文件存放的目录。--&gt; &lt;testOutputDirectory/&gt; &lt;!--使用来自该项目的一系列构建扩展--&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。--&gt; &lt;extension&gt; &lt;!--构建扩展的groupId--&gt; &lt;groupId/&gt; &lt;!--构建扩展的artifactId--&gt; &lt;artifactId/&gt; &lt;!--构建扩展的版本--&gt; &lt;version/&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt; &lt;defaultGoal/&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt; &lt;resource&gt; &lt;!--描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt; &lt;targetPath/&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt; &lt;filtering/&gt; &lt;!--描述存放资源的目录，该路径相对POM路径--&gt; &lt;directory/&gt; &lt;!--包含的模式列表，例如**/*.xml.--&gt; &lt;includes/&gt; &lt;!--排除的模式列表，例如**/*.xml--&gt; &lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录--&gt; &lt;directory/&gt; &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt; &lt;finalName/&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt; &lt;filters/&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt; &lt;extensions/&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息--&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id/&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase/&gt; &lt;!--配置的执行目标--&gt; &lt;goals/&gt; &lt;!--配置是否被传播到子POM--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表--&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt; &lt;id/&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志--&gt; &lt;activeByDefault/&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt; &lt;jdk/&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字--&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;)--&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本--&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt; &lt;property&gt; &lt;!--激活profile的属性的名称--&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值--&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。--&gt; &lt;exists&gt;/usr/local/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。--&gt; &lt;missing&gt;/usr/local/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素--&gt; &lt;build&gt; &lt;defaultGoal/&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素--&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports/&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素--&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素--&gt; &lt;properties/&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息--&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载--&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled/&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt; &lt;updatePolicy/&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt; &lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt; &lt;id&gt;zhangboxyz-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称--&gt; &lt;name&gt;zhangboxyz-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID--&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID--&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!--依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。--&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!--依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。--&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt; &lt;excludeDefaults/&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt; &lt;outputDirectory/&gt; &lt;!--使用的报表插件和他们的配置。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息--&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--报表插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的报表插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--报表插件的配置--&gt; &lt;configuration/&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到--&gt; &lt;id/&gt; &lt;!--产生报表集合时，被使用的报表的配置--&gt; &lt;configuration/&gt; &lt;!--配置是否被继承到子POMs--&gt; &lt;inherited/&gt; &lt;!--这个集合里使用到哪些报表--&gt; &lt;reports/&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!--继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt; &lt;uniqueVersion/&gt; &lt;id&gt;zhangboxyz-maven2&lt;/id&gt; &lt;name&gt;zhangboxyz maven2&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt; &lt;layout/&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion/&gt; &lt;id&gt;zhangboxyz-maven2&lt;/id&gt; &lt;name&gt;zhangboxyz-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/zhangboxyz:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout/&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息--&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt; &lt;id&gt;zhangboxyz-site&lt;/id&gt; &lt;!--部署位置的名称--&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt; &lt;url&gt; scp://svn.baidu.com/zhangboxyz:/var/www/localhost/zhangboxyz-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt; &lt;downloadUrl/&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt; &lt;relocation&gt; &lt;!--构件新的group ID--&gt; &lt;groupId/&gt; &lt;!--构件新的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--构件新的版本号--&gt; &lt;version/&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt; &lt;message/&gt; &lt;/relocation&gt; &lt;!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。--&gt; &lt;status/&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt; &lt;properties/&gt;&lt;/project&gt;","categories":[{"name":"Maven","slug":"Maven","permalink":"https://abcdoc-cn.github.io/categories/Maven/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Maven","slug":"Maven","permalink":"https://abcdoc-cn.github.io/tags/Maven/"}]},{"title":"Git常用命令","slug":"Git/Git 常用命令","date":"2021-04-23T05:24:27.000Z","updated":"2021-06-07T02:37:02.880Z","comments":true,"path":"Git/Git 常用命令/","link":"","permalink":"https://abcdoc-cn.github.io/Git/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Git 命令速查本地初始化项目 配置提交代码时的用户信息 12git config --global user.name &quot;你的名字或昵称&quot;git config --global user.email &quot;你的邮箱&quot; 创建初始化版本库，并推送到远程地址 12345git init## 添加远程仓库地址git remote add origin &lt;你的项目地址&gt; ## 推送到远程仓库git push -u origin master 从远程地址下载版本库 12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 创建/合并 dev 分支创建 dev 分支123git add .git commit -m ‘dev&#x27;git push -u origin dev 合并 dev 分支到 master12345678910# 切换到 master 分支git checkout master# pull 远程 master 到本地git pull origin master# 合并 dev 到 mastergit merge dev# 查看本地状态git status# push 本地到远程 mastergit push origin master 配置信息Git的配置文件为.gitconfig 全局配置： 用户主目录下 项目配置： 项目目录下 123456789# 显示当前的Git配置$ git config --list # 编辑Git配置文件$ git config -e [--global] # 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件12345678910111213141516171819202122# 添加指定文件到暂存区$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录$ git add [dir] # 添加当前目录的所有文件到暂存区$ git add . # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message] # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526272829303132333435363738# 列出所有tag$ git tag# 列出符合检索条件的 tag$ git tag -l 1.. # 查看tag信息$ git show [tag] # 新建一个tag在当前commit$ git tag [tag] # 新建一个tag在指定commit$ git tag [tag] [commit]# 新建一个带备注标签（推荐）$ git tag -a [tag] -m &quot;备注信息&quot;# 针对指定 commit 版本创建标签$ git tag -a [tag] [commit] -m &quot;备注信息&quot; # 删除本地tag$ git tag -d [tag]# 删除远程 tag（Git 版本 &gt; 1.7.0）$ git push origin --delete 1.0.0 # 删除远程 tag（Git 版本 &lt; 1.7.0)$ git push origin :refs/tags/[tagName] # 提交指定tag$ git push [remote] [tag] # 提交所有tag$ git push [remote] --tags # 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的代码差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog# 从本地master拉取代码更新当前分支：branch 一般为master$ git rebase [branch] 远程同步1234567891011121314151617181920212223242526272829303132333435# 更新远程仓储$ git remote update# 下载远程仓库的所有变动$ git fetch [remote] # 显示所有远程仓库$ git remote -v # 显示某个远程仓库的信息$ git remote show [remote] # 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 删除一个远程参数$ git remote rm [shortname] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force # 推送所有分支到远程仓库$ git push [remote] --all# 切换远程仓库地址$ git remote set-url origin &#123;新的 git 地址&#125;# 测试远程仓库地址$ git ls-remote -h -- &#123;git 地址&#125; HEAD 暂存区1234567891011121314151617181920212223242526272829303132# 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] # 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 生成公钥生成 SSH keys 公钥存放路径为：c:/Users/xxx/.ssh/ 1ssh-keygen -t rsa -C &quot;xxx@yyy.com&quot; 12345678910111213Generating public/private rsa key pair.#不填直接回车Enter file in which to save the key (/c/Users/xxx/.ssh/id_rsa):#输入密码（可以为空）Enter passphrase (empty for no passphrase):#再次确认密码（可以为空）Enter same passphrase again:#生成的密钥Your identification has been saved in /c/Users/xxx/.ssh/id_rsa.#生成的公钥Your public key has been saved in /c/Users/xxx/.ssh/id_rsa.pub.The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxx@yyy.com 测试 SSH keys 是否设置成功1$ ssh -T git@github.com 123456789The authenticity of host &#x27;github.com (192.30.252.129)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:xx:xx:xx:xx:xx:4d:eb:df:a6:48.#确认你是否继续联系，输入yesAre you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &#x27;github.com,192.30.252.129&#x27; (RSA) to the list of known hosts.#生成ssh kye是密码为空则无此项，若设置有密码则有此项且，输入生成ssh key时设置的密码即可。Enter passphrase for key &#x27;/c/Users/xxx/.ssh/id_rsa&#x27;: #出现词句话，说明设置成功。Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. TortoiseGit 配置 设置项目代理参数： –global 全局 – local 当前项目 12# 设置代理git config --local http.proxy 127.0.0.1:8580 12# 取消代理git config --local --unset http.proxy 忽略 SSL 验证服务器使用未经过 CA 签名的证书会导致客户端 clone 时报错： SSL certificate problem: self signed certificate TortoiseGit 配置 命令行配置1git config --system http.sslverify false","categories":[{"name":"GIt","slug":"GIt","permalink":"https://abcdoc-cn.github.io/categories/GIt/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"Git","slug":"Git","permalink":"https://abcdoc-cn.github.io/tags/Git/"}]}],"categories":[{"name":"VUE","slug":"VUE","permalink":"https://abcdoc-cn.github.io/categories/VUE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://abcdoc-cn.github.io/categories/SpringBoot/"},{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"},{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/categories/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/categories/MySQL/"},{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/categories/Java/"},{"name":"Electron","slug":"Electron","permalink":"https://abcdoc-cn.github.io/categories/Electron/"},{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/categories/C/"},{"name":"前端","slug":"前端","permalink":"https://abcdoc-cn.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://abcdoc-cn.github.io/categories/Nodejs/"},{"name":"默认分类","slug":"默认分类","permalink":"https://abcdoc-cn.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/categories/VS2015/"},{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/categories/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/categories/CentOS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://abcdoc-cn.github.io/categories/Hexo/"},{"name":"Maven","slug":"Maven","permalink":"https://abcdoc-cn.github.io/categories/Maven/"},{"name":"GIt","slug":"GIt","permalink":"https://abcdoc-cn.github.io/categories/GIt/"}],"tags":[{"name":"速查","slug":"速查","permalink":"https://abcdoc-cn.github.io/tags/%E9%80%9F%E6%9F%A5/"},{"name":"VUE","slug":"VUE","permalink":"https://abcdoc-cn.github.io/tags/VUE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://abcdoc-cn.github.io/tags/SpringBoot/"},{"name":"C","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"},{"name":"Oracle","slug":"Oracle","permalink":"https://abcdoc-cn.github.io/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://abcdoc-cn.github.io/tags/MySQL/"},{"name":"高可用","slug":"高可用","permalink":"https://abcdoc-cn.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"},{"name":"算法","slug":"算法","permalink":"https://abcdoc-cn.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Java","slug":"Java","permalink":"https://abcdoc-cn.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://abcdoc-cn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Electron","slug":"Electron","permalink":"https://abcdoc-cn.github.io/tags/Electron/"},{"name":"异常处理","slug":"异常处理","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"C++","slug":"C","permalink":"https://abcdoc-cn.github.io/tags/C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"Vditor","slug":"Vditor","permalink":"https://abcdoc-cn.github.io/tags/Vditor/"},{"name":"开发工具","slug":"开发工具","permalink":"https://abcdoc-cn.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"nodejs","slug":"nodejs","permalink":"https://abcdoc-cn.github.io/tags/nodejs/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://abcdoc-cn.github.io/tags/TCP-IP/"},{"name":"Typora","slug":"Typora","permalink":"https://abcdoc-cn.github.io/tags/Typora/"},{"name":"设计模式","slug":"设计模式","permalink":"https://abcdoc-cn.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"VS2015","slug":"VS2015","permalink":"https://abcdoc-cn.github.io/tags/VS2015/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://abcdoc-cn.github.io/tags/Jenkins/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://abcdoc-cn.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"SQLite","slug":"SQLite","permalink":"https://abcdoc-cn.github.io/tags/SQLite/"},{"name":"openssl","slug":"openssl","permalink":"https://abcdoc-cn.github.io/tags/openssl/"},{"name":"Linux","slug":"Linux","permalink":"https://abcdoc-cn.github.io/tags/Linux/"},{"name":"NTP","slug":"NTP","permalink":"https://abcdoc-cn.github.io/tags/NTP/"},{"name":"CentOS","slug":"CentOS","permalink":"https://abcdoc-cn.github.io/tags/CentOS/"},{"name":"HAProxy","slug":"HAProxy","permalink":"https://abcdoc-cn.github.io/tags/HAProxy/"},{"name":"Docker","slug":"Docker","permalink":"https://abcdoc-cn.github.io/tags/Docker/"},{"name":"批处理","slug":"批处理","permalink":"https://abcdoc-cn.github.io/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"STL","slug":"STL","permalink":"https://abcdoc-cn.github.io/tags/STL/"},{"name":"Hexo","slug":"Hexo","permalink":"https://abcdoc-cn.github.io/tags/Hexo/"},{"name":"Maven","slug":"Maven","permalink":"https://abcdoc-cn.github.io/tags/Maven/"},{"name":"Git","slug":"Git","permalink":"https://abcdoc-cn.github.io/tags/Git/"}]}